<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Hamza Adrat">
<meta name="author" content="Laurent Decreusefond">
<meta name="dcterms.date" content="2024-01-25">
<meta name="keywords" content="classification, point process, repulsion">

<title>Point Process Discrimination According to Repulsion</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="published_202401_adrat_repulsion_files/libs/clipboard/clipboard.min.js"></script>
<script src="published_202401_adrat_repulsion_files/libs/quarto-html/quarto.js"></script>
<script src="published_202401_adrat_repulsion_files/libs/quarto-html/popper.min.js"></script>
<script src="published_202401_adrat_repulsion_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="published_202401_adrat_repulsion_files/libs/quarto-html/anchor.min.js"></script>
<link href="published_202401_adrat_repulsion_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="published_202401_adrat_repulsion_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="published_202401_adrat_repulsion_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="published_202401_adrat_repulsion_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="published_202401_adrat_repulsion_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Point Process Discrimination According to Repulsion">
<meta name="citation_abstract" content="In numerous applications, cloud of points do seem to exhibit *repulsion* in the intuitive sense that there is no local cluster as in a Poisson process. Motivated by data coming from cellular networks, we devise a classification algorithm based on the form of the Voronoi cells. We show that, in the particular set of data we are given, we can retrieve some repulsiveness between antennas, which was expected for engineering reasons.

">
<meta name="citation_keywords" content="classification,point process,repulsion">
<meta name="citation_author" content="Hamza Adrat">
<meta name="citation_author" content="Laurent Decreusefond">
<meta name="citation_publication_date" content="2024-01-25">
<meta name="citation_cover_date" content="2024-01-25">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-01-25">
<meta name="citation_fulltext_html_url" content="https://computo.sfds.asso.fr/published_202401_adrat_repulsion/">
<meta name="citation_doi" content="10.57750/3r07-aw28">
<meta name="citation_issn" content="2824-7795">
<meta name="citation_language" content="en">
<meta name="citation_journal_title" content="Computo">
<meta name="citation_publisher" content="Société Française de Statistique">
<meta name="citation_reference" content="citation_title=Computo: Reproducible computational/algorithmic contributions in statistics and machine learning;,citation_author=Computo Team;,citation_publication_date=2021;,citation_cover_date=2021;,citation_year=2021;,citation_fulltext_html_url=https://computo.sfds.asso.fr/;,citation_journal_title=computo;">
<meta name="citation_reference" content="citation_title=Python: An ecosystem for scientific computing;,citation_author=Fernando Perez;,citation_author=Brian E Granger;,citation_author=John D Hunter;,citation_publication_date=2011;,citation_cover_date=2011;,citation_year=2011;,citation_issue=2;,citation_volume=13;,citation_journal_title=Computing in Science
&amp;amp;amp; Engineering;,citation_publisher=AIP Publishing;">
<meta name="citation_reference" content="citation_title=Https://www.cartoradio.fr;,citation_author=undefined ANFR;,citation_fulltext_html_url=https://www.cartoradio.fr;">
<meta name="citation_reference" content="citation_title=Stochastic Geometry and Wireless Networks: Volume I Theory;,citation_author=F. Baccelli;,citation_author=B. Błaszczyszyn;,citation_publication_date=2008;,citation_cover_date=2008;,citation_year=2008;,citation_issue=34;,citation_doi=10.1561/1300000006;,citation_issn=1554-057X;,citation_volume=3;,citation_journal_title=Foundations and Trends in Networking;">
<meta name="citation_reference" content="citation_title=Stochastic Geometry and Wireless Networks: Volume II Applications;,citation_author=F. Baccelli;,citation_author=B. Błaszczyszyn;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_issue=12;,citation_doi=10.1561/1300000026;,citation_issn=1554-057X;,citation_volume=4;,citation_journal_title=Foundations and Trends in Networking;">
<meta name="citation_reference" content="citation_title=The ginibre point process as a model for wireless networks with repulsion;,citation_abstract=The spatial structure of transmitters in wireless networks plays a key role in evaluating the mutual interference and hence the performance. Although the Poisson point process (PPP) has been widely used to model the spatial configuration of wireless networks, it is not suitable for networks with repulsion. The Ginibre point process (GPP) is one of the main examples of determinantal point processes that can be used to model random phenomena where repulsion is observed. Considering the accuracy, tractability and practicability tradeoffs, we introduce and promote the \beta-GPP, an intermediate class between the PPP and the GPP, as a model for wireless networks when the nodes exhibit repulsion. To show that the model leads to analytically tractable results in several cases of interest, we derive the mean and variance of the interference using two different approaches: the Palm measure approach and the reduced second moment approach, and then provide approximations of the interference distribution by three known probability density functions. Besides, to show that the model is relevant for cellular systems, we derive the coverage probability of the typical user and also find that the fitted \beta-GPP can closely model the deployment of actual base stations in terms of the coverage probability and other statistics.;,citation_author=Na Deng;,citation_author=Wuyang Zhou;,citation_author=Martin Haenggi;,citation_publication_date=2015;,citation_cover_date=2015;,citation_year=2015;,citation_fulltext_html_url=https://arxiv.org/abs/1401.3677v1;,citation_issue=1;,citation_volume=14;,citation_journal_title=IEEE Transactions on Wireless Communications;">
<meta name="citation_reference" content="citation_title=The Palm measure and the Voronoi tessellation for the Ginibre process;,citation_abstract=We prove that the Palm measure of the Ginibre process is obtained by removing a Gaussian distributed point from the process and adding the origin. We obtain also precise formulas describing the law of the typical cell of Ginibre–Voronoi tessellation. We show that near the germs of the cells a more important part of the area is captured in the Ginibre–Voronoi tessellation than in the Poisson–Voronoi tessellation. Moment areas of corresponding subdomains of the cells are explicitly evaluated.;,citation_author=André Goldman;,citation_publication_date=2010-02;,citation_cover_date=2010-02;,citation_year=2010;,citation_fulltext_html_url=https://arxiv.org/abs/math/0610243;,citation_issue=1;,citation_doi=10.1214/09-AAP620;,citation_issn=1050-5164;,citation_volume=20;,citation_journal_title=The Annals of Applied Probability;">
<meta name="citation_reference" content="citation_title=A case study on regularity in cellular network deployment;,citation_abstract=This paper aims to validate the \beta-Ginibre point process as a model for the distribution of base station locations in a cellular network. The \beta-Ginibre is a repulsive point process in which repulsion is controlled by the \beta parameter. When \beta tends to zero, the point process converges in law towards a Poisson point process. If \beta equals to one it becomes a Ginibre point process. Simulations on real data collected in Paris (France) show that base station locations can be fitted with a \beta-Ginibre point process. Moreover we prove that their superposition tends to a Poisson point process as it can be seen from real data. Qualitative interpretations on deployment strategies are derived from the model fitting of the raw data.;,citation_author=Jean-Sébastien Gomez;,citation_author=Aurélien Vasseur;,citation_author=Anaı̈s Vergne;,citation_author=Philippe Martins;,citation_author=Laurent Decreusefond;,citation_author=Wei Chen;,citation_publication_date=2015-05-22;,citation_cover_date=2015-05-22;,citation_year=2015;,citation_fulltext_html_url=https://arxiv.org/abs/1505.06073v1;,citation_journal_title=IEEE Wireless Communications Letters, IEEE, 2015, pp.4;">
<meta name="citation_reference" content="citation_title=Determinantal processes and independence;,citation_author=J. B. Hough;,citation_author=M. Krishnapur;,citation_author=Y. Peres;,citation_author=B. Virág;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_issn=1549-5787;,citation_volume=3;,citation_journal_title=Probability Surveys;">
<meta name="citation_reference" content="citation_title=Spatial modeling and analysis of cellular networks using the Ginibre point process: A tutorial;,citation_author=Naoto Miyoshi;,citation_author=Tomoyuki Shirai;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_issue=11;,citation_doi=10.1587/transcom.2016nei0001;,citation_volume=E99.B;,citation_journal_title=IEICE Transactions on Communications;,citation_publisher=Institute of Electronics, Information; Communications Engineers (IEICE);">
<meta name="citation_reference" content="citation_title=Trace ideals and their applications;,citation_author=B. Simon;,citation_publication_date=2005;,citation_cover_date=2005;,citation_year=2005;,citation_isbn=0-8218-3581-5;,citation_volume=120;,citation_series_title=Mathematical surveys and monographs;">
<meta name="citation_reference" content="citation_title=Optimal transport, old and new;,citation_author=C. Villani;,citation_publication_date=2007;,citation_cover_date=2007;,citation_year=2007;,citation_series_title=Lectures notes in mathematics;">
<meta name="citation_reference" content="citation_title=An introduction to the theory of point processes. Vol. I;,citation_author=D. J. Daley;,citation_author=D. Vere-Jones;,citation_publication_date=2003;,citation_cover_date=2003;,citation_year=2003;,citation_isbn=0-387-95541-0;,citation_series_title=Probability and its applications (new york);">
<meta name="citation_reference" content="citation_title=Conditional intensity and Gibbsianness of determinantal point processes;,citation_author=Hans-Otto Georgii;,citation_author=Hyun Jae Yoo;,citation_publication_date=2005;,citation_cover_date=2005;,citation_year=2005;,citation_issue=1-2;,citation_doi=10.1007/s10955-004-8777-5;,citation_issn=0022-4715;,citation_volume=118;,citation_journal_title=Journal of Statistical Physics;">
<meta name="citation_reference" content="citation_title=Optimal transport between determinantal point processes and application to fast simulation;,citation_author=Laurent Decreusefond;,citation_author=Guillaume Moroz;,citation_publication_date=2021;,citation_cover_date=2021;,citation_year=2021;,citation_issue=2;,citation_issn=2351-6046;,citation_volume=8;,citation_journal_title=Mod. Stoch. Theory Appl.;">
<meta name="citation_reference" content="citation_title=Pairwise interaction processes for modeling cellular network topology;,citation_author=D. B. Taylor;,citation_author=H. S. Dhillon;,citation_author=T. D. Novlan;,citation_author=J. G. Andrews;,citation_publication_date=2012;,citation_cover_date=2012;,citation_year=2012;,citation_doi=10.1109/glocom.2012.6503831;,citation_conference_title=Globecom;">
<meta name="citation_reference" content="citation_title=Asymptotics of superposition of point processes;,citation_author=L. Decreusefond;,citation_author=A. Vasseur;,citation_publication_date=2015-10;,citation_cover_date=2015-10;,citation_year=2015;,citation_conference_title=Geometry of Science Information;">
<meta name="citation_reference" content="citation_title=A note on the simulation of the Ginibre point process;,citation_author=L. Decreusefond;,citation_author=I. Flint;,citation_author=A. Vergne;,citation_publication_date=2015-12;,citation_cover_date=2015-12;,citation_year=2015;,citation_issue=04;,citation_doi=10.1239/jap/1450802749;,citation_volume=52;,citation_journal_title=Journal of Applied Probability;,citation_publisher=Cambridge University Press (CUP);">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Point Process Discrimination According to Repulsion</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://www.linkedin.com/in/hamza-adrat/">Hamza Adrat</a> <a href="https://orcid.org/0009-0004-8155-3260" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.emines-ingenieur.org/">
                  Mohammed VI Polytechnic University
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.telecom-paris.fr/~decreuse">Laurent Decreusefond</a> <a href="https://orcid.org/0000-0002-8964-0957" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://telecom-paris.fr">
                  Telecom Paris
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">February 18, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">classification, point process, repulsion</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <a href="https://github.com/computorg/published_202401_adrat_repulsion/"><img src="https://github.com/computorg/published_202401_adrat_repulsion//actions/workflows/build.yml/badge.svg" alt="build status"></a>
                    <p class="date"></p>
        <a href="https://github.com/computorg/published_202401_adrat_repulsion//issues?q=is%3Aopen+is%3Aissue+label%3Areview"><img src="https://img.shields.io/badge/reviews-reports-blue" alt="reviews"></a>
            </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>In numerous applications, cloud of points do seem to exhibit <em>repulsion</em> in the intuitive sense that there is no local cluster as in a Poisson process. Motivated by data coming from cellular networks, we devise a classification algorithm based on the form of the Voronoi cells. We show that, in the particular set of data we are given, we can retrieve some repulsiveness between antennas, which was expected for engineering reasons.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#preliminaries" id="toc-preliminaries" class="nav-link" data-scroll-target="#preliminaries"><span class="header-section-number">2</span> Preliminaries</a></li>
  <li><a href="#classification-of-cartoradio-data" id="toc-classification-of-cartoradio-data" class="nav-link" data-scroll-target="#classification-of-cartoradio-data"><span class="header-section-number">3</span> Classification of Cartoradio data</a>
  <ul class="collapse">
  <li><a href="#statistical-approach" id="toc-statistical-approach" class="nav-link" data-scroll-target="#statistical-approach"><span class="header-section-number">3.1</span> Statistical approach</a></li>
  <li><a href="#machine-learning-approach" id="toc-machine-learning-approach" class="nav-link" data-scroll-target="#machine-learning-approach"><span class="header-section-number">3.2</span> Machine Learning approach</a></li>
  <li><a href="#cartoradio-data-tests" id="toc-cartoradio-data-tests" class="nav-link" data-scroll-target="#cartoradio-data-tests"><span class="header-section-number">3.3</span> Cartoradio data Tests</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">4</span> Conclusion</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliography</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="published_202401_adrat_repulsion.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>In the performance analysis of cellular systems, the locations of antennas (or base stations) play a major role (see <span class="citation" data-cites="BaccelliStochasticGeometryWireless2008">Baccelli and Błaszczyszyn (<a href="#ref-BaccelliStochasticGeometryWireless2008" role="doc-biblioref">2008</a>)</span>). It is usually admitted that they can be modeled by a Poisson process. But the data which can be gathered from the Web site of the French National Agency of Radio Frequencies, Cartoradio, see <span class="citation" data-cites="ANFR">ANFR (<a href="#ref-ANFR" role="doc-biblioref">n.d.</a>)</span>, tend to prove that this may not be the case. More precisely, if we look at the global picture of all antennas in Paris, we see features reminiscent of a Poisson process (local clusters for instance), see <a href="#fig-paris-orange" class="quarto-xref">Figure&nbsp;1</a> (left). However, if we look closer and finer, by specifying a region and a frequency band, we see that the antennas locations do seem to exhibit some repulsion (see <a href="#fig-paris-orange" class="quarto-xref">Figure&nbsp;1</a>, right picture).</p>
<div id="fig-paris-orange" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-paris-orange-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./figures/paris-orange.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-paris-orange-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Left: Antennas in Paris. Right: Antennas in one frequency band only.
</figcaption>
</figure>
</div>
<p>In previous papers, point processes with repulsion have been used to model such systems <span class="citation" data-cites="Deng2014 Miyoshi2016 Gomez2015">(<a href="#ref-Deng2014" role="doc-biblioref">Deng, Zhou, and Haenggi 2015</a>; <a href="#ref-Miyoshi2016" role="doc-biblioref">Miyoshi and Shirai 2016</a>; <a href="#ref-Gomez2015" role="doc-biblioref">Gomez et al. 2015</a>)</span> for no reason but a mere resemblance between the pictures like the right picture in {numref}<code>paris-orange-fig</code> and those obtained by simulating a point process with repulsion. The question is then to decide, given one sample of positions of base stations in a bounded domain, whether it is more likely to be modeled by a point process with repulsion or by a <em>neutral</em> point process, i.e.&nbsp;where the locations could be considered as coming from independent drawings of some identically distributed random variables. As we only have a single realization, we cannot use frequency methods. Since the observation window is finite, we cannot either resort to estimates based on stationarity or ergodicity and we must take care from the side effects.</p>
<p>The rationale behind our work comes from <span class="citation" data-cites="goldman_palm_2010">Goldman (<a href="#ref-goldman_palm_2010" role="doc-biblioref">2010</a>)</span>. It is shown there that the Voronoi cells of the Ginibre point process (a particular point process with repulsion, see below for the exact definition) are in some sense more regular (closer to a circle) than those of a Poisson process (see <a href="#eq-theorem-goldman" class="quarto-xref">Equation&nbsp;3</a> in <a href="#thm-goldman" class="quarto-xref">Theorem&nbsp;1</a>). By simulation, this feature seems to persist for other point processes with repulsion, like Gibbs processes. In <span class="citation" data-cites="Taylor2012">Taylor et al. (<a href="#ref-Taylor2012" role="doc-biblioref">2012</a>)</span>, the surface of Voronoi cells is claimed to be a good discrepancy indicator between Poisson process and several processes with repulsion (Gibbs processes, Strauss processes with repulsion and the Geyer saturation model). For any of these models, we do not have any closed formula on the surface of the Voronoi cells so the procedure proposed in this paper is to simulate a large number of realizations of each of these processes and compute the empirical mean and variance of the Voronoi cells area. They obtain mixed conclusions as this sole indicator does not enable to rule out the Poisson hypothesis for many situations.</p>
<p>Our contribution is to consider the ratio of the surface by the squared perimeter instead of the surface of the Voronoi cells alone. Actually, we can interpret the result of <span class="citation" data-cites="goldman_palm_2010">Goldman (<a href="#ref-goldman_palm_2010" role="doc-biblioref">2010</a>)</span> by saying that the Voronoi cells of a Ginibre point process are more circular than those of a Poisson point process. The isoperimetric inequality stands for any regular enough domain in the plane, <span class="math inline">R = \frac{4 \pi S}{P^2}</span> is less than <span class="math inline">1</span> and the equality is obtained for disks. It is thus sensible to think that the ratio <span class="math inline">R</span> will be closer to <span class="math inline">1</span> for repulsive processes than for neutral point processes. Following the procedure of <span class="citation" data-cites="Taylor2012">Taylor et al. (<a href="#ref-Taylor2012" role="doc-biblioref">2012</a>)</span>, we show that we get a much better indicator by using <span class="math inline">R</span> instead <span class="math inline">S</span> alone to discriminate between repulsive and neutral point processes.</p>
<p>However, for the application we have in mind, which is to decide for one single map which model is the most pertinent, we cannot use this criterion based on probability. That is why we resort to an ML model. After several tries, we concluded that the most efficient algorithm was to use Logistic Regression. In a first step, we trained it on simulations of Ginibre and Poisson point processes. The advantage of the Ginibre process is that we have efficient algorithm to simulate it <span class="citation" data-cites="MR4279876">(<a href="#ref-MR4279876" role="doc-biblioref">Laurent Decreusefond and Moroz 2021</a>)</span> and it does not seem to alter the accuracy of our algorithm to use one single class of repulsive point process. We remarked that we obtain a much better discrimination by considering the mean value of <span class="math inline">R</span> for the five most central cells instead of just the most central one. We can even improve our discrimination rate by adding to the input vector the value of each of the five ratios.</p>
<p>Furthermore, the repulsion in the Ginibre class of point processes can be also modulated by making a <span class="math inline">\beta</span>-thinning (to weaken the repulsion) and then a <span class="math inline">\sqrt{\beta}</span>-dilation (to keep the same intensity of points per surface unit) to obtain what is called a <span class="math inline">\beta</span>-Ginibre. For <span class="math inline">\beta=1</span>, we have the original Ginibre process and when <span class="math inline">\beta</span> goes to <span class="math inline">0</span>, it tends in law to a Poisson process (see <span class="citation" data-cites="DecreusefondAsymptoticssuperpositionpoint2015">L. Decreusefond and Vasseur (<a href="#ref-DecreusefondAsymptoticssuperpositionpoint2015" role="doc-biblioref">2015</a>)</span>) so that we have a full scale of point processes with intermediate repulsion between <span class="math inline">0</span> and <span class="math inline">1</span>. We show that our logistic regression algorithm can still accurately discriminate between Poisson and <span class="math inline">\beta</span>-repulsive point processes for <span class="math inline">\beta</span> up to <span class="math inline">0.7</span>.</p>
<p>The paper is organized as follows. We first remind what is a Ginibre point process and the property of its Voronoi cells which motivates the sequel. Then two approaches are employed, one based on statistics and the other on machine learning, to classify the processes and compare their efficiencies and outcomes. Finally, tests are conducted on the Cartoradio data.</p>
</section>
<section id="preliminaries" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="preliminaries"><span class="header-section-number">2</span> Preliminaries</h2>
<p>We consider finite point processes on a bounded window <span class="math inline">E</span>. The law of a such a point process <span class="math inline">N</span> can be characterized by its correlation functions (for details we refer to <span class="citation" data-cites="Daley2003">Daley and Vere-Jones (<a href="#ref-Daley2003" role="doc-biblioref">2003, chap. 5</a>)</span>). These are symmetric functions <span class="math inline">(\rho_{k},k\ge 1)</span> such that for any bounded function <span class="math inline">f</span>, we can write:</p>
<p><span class="math display">
\mathbb{E}\left[ \sum_{\alpha \subset N} f(\alpha) \right] = \sum_{k=1}^{+ \infty} \frac{1}{k!} \int_{E^k} f(\{x_1, \dots, x_k\}) \rho_{k}(x_1, \dots, x_k) \, d x_1 \dots d x_k .
</span></p>
<p>Intuitively speaking, <span class="math inline">\rho_{k}(x_{1}, \dots, x_{k}) \, d x_{1} \dots d x_{k}</span> represents the probability to observe in <span class="math inline">N</span>, at least <span class="math inline">k</span> points located around the point <span class="math inline">x_{j}</span>. For a Poisson point process of control measure <span class="math inline">m(x) \, dx</span>, we have</p>
<p><span class="math display">
\rho_{k}(x_{1}, \dots, x_{k}) = \prod_{j=1}^{k} m(x_{j}).
</span></p>
<p>The <strong>Ginibre point process</strong>, restricted to <span class="math inline">E=B(0,r)</span>, with intensity <span class="math inline">\rho = \frac{\lambda}{\pi}</span> (with <span class="math inline">\lambda &gt; 0</span>) has correlation functions (see <span class="citation" data-cites="Decreusefond_2015">L. Decreusefond, Flint, and Vergne (<a href="#ref-Decreusefond_2015" role="doc-biblioref">2015</a>)</span>)</p>
<p><span id="eq-correlation_functions_determinantal"><span class="math display">
\rho_{k}(x_1, \dots, x_k) = \det(K(x_i, x_j), \; 1 \le i,j \le k)
\tag{1}</span></span> where <span class="math inline">K</span> is given by</p>
<p><span id="eq-main"><span class="math display">
K_r(x,y)=\sum_{j=1}^\infty \frac{\gamma(j+1,r^2)}{j!} \phi_j(x)\phi_j(\bar y)
\tag{2}</span></span> with</p>
<p><span class="math display">
\phi_j(x) = \sqrt{\frac{\rho}{\gamma(j+1,r^2)}} \left(\sqrt{\lambda} x \right)^j \, e^{-\frac{\lambda}{2} |x|^2}
</span></p>
<p>and <span class="math inline">\gamma(n,x)</span> is the lower incomplete Gamma function. The simulation of such a point process is a delicate matter, first solved in <span class="citation" data-cites="HoughDeterminantalprocessesindependence2006">Hough et al. (<a href="#ref-HoughDeterminantalprocessesindependence2006" role="doc-biblioref">2006</a>)</span>. It remains costly because the algorithm contains complex calculations and some rejections. In order to fasten the procedure, an approximate algorithm, with error estimates, has been given in <span class="citation" data-cites="MR4279876">Laurent Decreusefond and Moroz (<a href="#ref-MR4279876" role="doc-biblioref">2021</a>)</span> (see the bibliography therein to get the URL of the Python code).</p>
<p>For an at most denumerable set of points <span class="math inline">\{x_{n}, \, n \ge 1\}</span>, the Voronoi cells are defined as the convex sets</p>
<p><span class="math display">
\mathcal{C}(x_{i})=\{z \in \mathbb{C},\ |z-x_{i}|\le |z-x_{j}|  \text{ for all }j\neq i\}.
</span></p>
<p>When the points are drawn from a point process, we thus have a collection of random closed sets. When the process under consideration is stationary with respect to translations, it is customary to define the typical law of a Voronoi cell as the law of the cell containing the origin of <span class="math inline">\mathbb{R}^{2}</span> when the point process is taken under its Palm distribution <span class="citation" data-cites="goldman_palm_2010 BaccelliStochasticGeometryWireless2009">(<a href="#ref-goldman_palm_2010" role="doc-biblioref">Goldman 2010</a>; <a href="#ref-BaccelliStochasticGeometryWireless2009" role="doc-biblioref">Baccelli and Błaszczyszyn 2009</a>)</span>. It turns out that we know the Palm distribution of the Poisson process (which is itself) and of the Ginibre point process (the correlation functions are of the form <a href="#eq-correlation_functions_determinantal" class="quarto-xref">Equation&nbsp;1</a> with <span class="math inline">K</span> being <span class="math inline">K_{R}</span> with the first term removed). We denote by <span class="math inline">\mathcal{C}_p</span> (respectively <span class="math inline">\mathcal{C}_{G}</span>) the typical cell of the Voronoi tessellation associated to a stationary Poisson process in <span class="math inline">\mathbb{C}</span> with intensity <span class="math inline">\lambda</span> (respectively to the Ginibre point process of intensity <span class="math inline">\rho</span>). One of the main theorems of <span class="citation" data-cites="goldman_palm_2010">Goldman (<a href="#ref-goldman_palm_2010" role="doc-biblioref">2010</a>)</span> is the following.</p>
<div id="thm-goldman" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1</strong></span> When <span class="math inline">r \to 0,</span> <span id="eq-theorem-goldman"><span class="math display">
\mathbb{E} \left[ V(\mathcal{C}_{G} \cap B(0,r)) \right] = \mathbb{E} \left[ V(\mathcal{C}_p \cap B(0,r)) \right] (1 + r^2 W + \circ(r^2))
\tag{3}</span></span> where <span class="math inline">W</span> is a positive random variable.</p>
</div>
<p><a href="#thm-goldman" class="quarto-xref">Theorem&nbsp;1</a> shows that near the germs of the cells a more important part of the area is captured in the Ginibre–Voronoi tessellation than in the Poisson–Voronoi tessellation. This is an indication that the Voronoi cells of the Ginibre point process are more circular than those given by the Poisson process. This can be corroborated by simulation as shows <a href="#fig-voronoi" class="quarto-xref">Figure&nbsp;2</a>.</p>
<div id="fig-voronoi" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-voronoi-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./figures/Voronoi.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-voronoi-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: On the left, Voronoi cells associated to a realization of a Ginibre process. On the right, Voronoi cells associated to a realization of a Poisson process.
</figcaption>
</figure>
</div>
<p>As we know that circles saturate the isoperimetric inequality, it is sensible to consider classification algorithms based on area and squared perimeter of Voronoi cells. In order to avoid side effects, we concentrate on the innermost cells of the observation window.</p>
</section>
<section id="classification-of-cartoradio-data" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="classification-of-cartoradio-data"><span class="header-section-number">3</span> Classification of Cartoradio data</h2>
<p>The Cartoradio web site contains the locations (in GPS coordinates) and other informations about all the antennas (or base stations) in metropolitan France for any operator, any frequency band and all generation of wireless systems (2G to 5G). The capacity of an antenna depends on its power and on the traffic demand it has to serve. Outside metropolitan areas, the antennas are relatively scarce and located along the main roads to guarantee a large surface coverage (around 30 km<span class="math inline">^2</span>). Hence there is no need to construct models for these regions. On the contrary, in big towns, the density of base stations is much higher to handle the traffic demand: An antenna covers around half a squared kilometer. This is where the dimensioning problem do appear. One should have a sufficient number of antennas per unit of surface to transport all the traffic, on the other hand, base stations operating in a given frequency band cannot be to close to mitigate interference. This explains the right picture of <a href="#fig-paris-orange" class="quarto-xref">Figure&nbsp;1</a>.</p>
<p>When it comes to assess the type of point process we should consider in this situation, we cannot consider the city as a whole: the geography (notably the Seine river in Paris, the parks, etc.), the non uniformity of demands (the traffic is heavier aroung railway stations or touristic sites, for instance) which entails a higher density of antennas, ruin any kind of invariance a statistician could hope for. For instance, the lack of homogeneity prevents the use of traditional repulsion criteria, such as pair correlation. That means, we should restrict our expectations to local models of the size of a district or a bit more. Since interference, which are the main annoyance to be dealt with, are a local phenomenon, working on a partial part of the whole domain is sufficient to predict the behavior and dimension a wireless network.</p>
<p>In the following sections, we will use Python code that assumes that the following packages have been loaded:</p>
<div id="52372889" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> bernoulli</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Voronoi, ConvexHull</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>font <span class="op">=</span> {<span class="st">'family'</span>: <span class="st">'serif'</span>, <span class="st">'color'</span>:  <span class="st">'black'</span>, <span class="st">'weight'</span>: <span class="st">'normal'</span>, <span class="st">'size'</span>: <span class="dv">11</span>,}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="statistical-approach" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="statistical-approach"><span class="header-section-number">3.1</span> Statistical approach</h3>
<p>Given a circular domain with <span class="math inline">N</span> points, we want to decide whether the points exhibit repulsion or not. To do so, we will begin with a statistical approach, where we will first calculate, for Poisson processes as well as for Ginibre and <span class="math inline">\beta</span>-Ginibre processes, the probability that the ratio <span class="math inline">R = \frac{4 \pi S}{P^2}</span> of the central cell is less than or equal to <span class="math inline">r</span>, for values of <span class="math inline">r</span> ranging from <span class="math inline">0</span> to <span class="math inline">1</span>. And then we apply the same approach using the mean ratio of the five central cells. Finally, we will calculate <span class="math inline">95</span>% confidence intervals for each of these processes.</p>
<p>The following code illustrates the generation of various point samples and the calculation of the surface to squared perimeter ratios given the number of points <span class="math inline">N</span> and the parameter <span class="math inline">\beta</span> for <span class="math inline">\beta</span>-Ginibre processes. The Ginibre and <span class="math inline">\beta</span>-Ginibre processes are generated using the “sample” function given in the Python code of <span class="citation" data-cites="MR4279876">Laurent Decreusefond and Moroz (<a href="#ref-MR4279876" role="doc-biblioref">2021</a>)</span>.</p>
<div id="885fb2ae" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> in_box(towers, bounding_box):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.logical_and(np.logical_and(bounding_box[<span class="dv">0</span>] <span class="op">&lt;=</span> towers[:, <span class="dv">0</span>], towers[:, <span class="dv">0</span>] <span class="op">&lt;=</span> bounding_box[<span class="dv">1</span>]),</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                          np.logical_and(bounding_box[<span class="dv">2</span>] <span class="op">&lt;=</span> towers[:, <span class="dv">1</span>], towers[:, <span class="dv">1</span>] <span class="op">&lt;=</span> bounding_box[<span class="dv">3</span>]))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> voronoi(towers, bounding_box, N):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select towers inside the bounding box</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> in_box(towers, bounding_box)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror points</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    points_center <span class="op">=</span> towers[i, :]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    points_left <span class="op">=</span> np.copy(points_center)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    points_left[:, <span class="dv">0</span>] <span class="op">=</span> bounding_box[<span class="dv">0</span>] <span class="op">-</span> (points_left[:, <span class="dv">0</span>] <span class="op">-</span> bounding_box[<span class="dv">0</span>])</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    points_right <span class="op">=</span> np.copy(points_center)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    points_right[:, <span class="dv">0</span>] <span class="op">=</span> bounding_box[<span class="dv">1</span>] <span class="op">+</span> (bounding_box[<span class="dv">1</span>] <span class="op">-</span> points_right[:, <span class="dv">0</span>])</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    points_down <span class="op">=</span> np.copy(points_center)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    points_down[:, <span class="dv">1</span>] <span class="op">=</span> bounding_box[<span class="dv">2</span>] <span class="op">-</span> (points_down[:, <span class="dv">1</span>] <span class="op">-</span> bounding_box[<span class="dv">2</span>])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    points_up <span class="op">=</span> np.copy(points_center)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    points_up[:, <span class="dv">1</span>] <span class="op">=</span> bounding_box[<span class="dv">3</span>] <span class="op">+</span> (bounding_box[<span class="dv">3</span>] <span class="op">-</span> points_up[:, <span class="dv">1</span>])</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> np.append(points_center,</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                       np.append(np.append(points_left, points_right, axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                                 np.append(points_down, points_up, axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                                 axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                       axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute Voronoi</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    vor <span class="op">=</span> Voronoi(points)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    vor.filtered_points <span class="op">=</span> points_center</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    vor.filtered_regions <span class="op">=</span> [vor.regions[vor.point_region[i]] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(points_center))]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> central_area_perim(vor):</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ConvexHull(vor.vertices[vor.filtered_regions[<span class="dv">0</span>], :]).volume, ConvexHull(vor.vertices[vor.filtered_regions[<span class="dv">0</span>], :]).area</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> area_perim(vor):</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    area, perimeter <span class="op">=</span> [], []</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(vor.filtered_regions) <span class="op">&gt;=</span> i:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            area.append(ConvexHull(vor.vertices[vor.filtered_regions[i], :]).volume)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            perimeter.append(ConvexHull(vor.vertices[vor.filtered_regions[i], :]).area)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            area.append(np.mean(area))</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            perimeter.append(np.mean(perimeter))</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> area, perimeter</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ginibre(N, cells):</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> (np.sqrt(N)) <span class="op">;</span> precision <span class="op">=</span> <span class="dv">2</span><span class="op">**-</span><span class="dv">53</span> <span class="op">;</span> error <span class="op">=</span> <span class="va">False</span> <span class="op">;</span> quiet<span class="op">=</span><span class="va">True</span> <span class="op">;</span> output<span class="op">=</span><span class="va">None</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> [radius, N, kernels[<span class="st">'ginibre'</span>], precision, error, quiet, output]</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    sample_ginibre <span class="op">=</span> sample(<span class="op">*</span>args)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    X_ginibre, Y_ginibre <span class="op">=</span> sample_ginibre.real, sample_ginibre.imag</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    ginibre_points <span class="op">=</span> np.array([X_ginibre, Y_ginibre]).T</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((ginibre_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((ginibre_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    ginibre_points <span class="op">=</span> ginibre_points[indices]</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    ginibre_vor <span class="op">=</span> voronoi(ginibre_points, (<span class="op">-</span>np.sqrt(N)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N)<span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>np.sqrt(N)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N)<span class="op">+</span><span class="fl">.1</span>), <span class="bu">len</span>(ginibre_points))</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(ginibre_vor)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(ginibre_vor)</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beta_ginibre(N, beta, cells):</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> (np.sqrt(N)) <span class="op">;</span> precision <span class="op">=</span> <span class="dv">2</span><span class="op">**-</span><span class="dv">53</span> <span class="op">;</span> error <span class="op">=</span> <span class="va">False</span> <span class="op">;</span> quiet<span class="op">=</span><span class="va">True</span> <span class="op">;</span> output<span class="op">=</span><span class="va">None</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> [radius, N, kernels[<span class="st">'ginibre'</span>], precision, error, quiet, output]</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    sample_init <span class="op">=</span> sample(<span class="op">*</span>args)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    sample_beta_ginibre <span class="op">=</span> sample_init<span class="op">*</span>(bernoulli.rvs(beta, size<span class="op">=</span>N))</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    sample_beta_ginibre <span class="op">=</span> np.array([a <span class="cf">for</span> a <span class="kw">in</span> sample_beta_ginibre <span class="cf">if</span> a <span class="op">!=</span> <span class="dv">0</span>])<span class="op">*</span>(np.sqrt(beta))</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>    X_beta_ginibre, Y_beta_ginibre <span class="op">=</span> sample_beta_ginibre.real, sample_beta_ginibre.imag</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_points <span class="op">=</span> np.array([X_beta_ginibre, Y_beta_ginibre]).T</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((beta_ginibre_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((beta_ginibre_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_points <span class="op">=</span> beta_ginibre_points[indices]</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_vor <span class="op">=</span> voronoi(beta_ginibre_points,</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>                               (<span class="op">-</span>np.sqrt(N<span class="op">*</span>beta)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N<span class="op">*</span>beta)<span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>np.sqrt(N<span class="op">*</span>beta)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N<span class="op">*</span>beta)<span class="op">+</span><span class="fl">.1</span>),</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">len</span>(beta_ginibre_points))</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(beta_ginibre_vor)</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(beta_ginibre_vor)</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> poisson(N, cells):</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> np.sqrt(N)</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> scipy.stats.uniform.rvs(<span class="dv">0</span>,<span class="dv">1</span>,N)</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> radius <span class="op">*</span> np.sqrt(scipy.stats.uniform.rvs(<span class="dv">0</span>,<span class="dv">1</span>,N))</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>    X_poisson, Y_poisson <span class="op">=</span> r<span class="op">*</span>np.cos(alpha), r<span class="op">*</span>np.sin(alpha)</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    poisson_points <span class="op">=</span> np.array([X_poisson, Y_poisson]).T</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((poisson_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((poisson_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>    poisson_points <span class="op">=</span> poisson_points[indices]</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>    poisson_vor <span class="op">=</span> voronoi(poisson_points, (<span class="op">-</span>radius <span class="op">-</span><span class="fl">.1</span>, radius <span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>radius <span class="op">-</span><span class="fl">.1</span>, radius <span class="op">+</span><span class="fl">.1</span>), <span class="bu">len</span>(poisson_points))</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(poisson_vor)</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(poisson_vor)</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_ginibre(N, cells):</span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> ginibre(N, cells)</span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(G)[<span class="dv">0</span>]<span class="op">/</span>(np.array(G)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_beta_ginibre(N, beta, cells):</span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>    beta_G <span class="op">=</span> beta_ginibre(N, beta, cells)</span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(beta_G)[<span class="dv">0</span>]<span class="op">/</span>(np.array(beta_G)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_poisson(N, cells):</span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> poisson(N, cells)</span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(P)[<span class="dv">0</span>]<span class="op">/</span>(np.array(P)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>run <span class="op">-</span>i Moroz_dpp.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Importing libraries ...
Compiling functions ...</code></pre>
</div>
</div>
<p>The simulation algorithm provides a method for computing the quantity <span class="math inline">\mathbb{P} \left( \frac{4 \pi S}{P^2} \le r \right)</span> as a function of <span class="math inline">r</span> for the Ginibre processes (the same algorithm is applied to other processes as well). The Algorithm takes as input the number of points <span class="math inline">N</span>, the number of experiences for the simulation <span class="math inline">N_{exp}</span> and the range of the variable <span class="math inline">r</span> as a list of values. Since the simulations require a lot of time to run, we are not going to attach the associated Python code, the latter is based on the algorithm described in the following Python code using the functions defined previously.</p>
<div id="3b609b28" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulation(N, N_exp, list_r):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    W_chap_ginibre, W_chap_poisson, W_chap_g7 <span class="op">=</span> [], [], []</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    l_ginibre, l_poisson, l_g7 <span class="op">=</span> [], [], []</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_exp):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        l_ginibre.append(ratio_ginibre(N))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        l_poisson.append(ratio_poisson(N))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        l_g7.append(ratio_beta_ginibre(N, <span class="fl">0.7</span>))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> list_r:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        W_chap_ginibre.append((np.array(l_ginibre) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        W_chap_poisson.append((np.array(l_poisson) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        W_chap_g7.append((np.array(l_g7) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    p_chap_ginibre <span class="op">=</span> (np.array(W_chap_ginibre)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    p_chap_poisson <span class="op">=</span> (np.array(W_chap_poisson)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    p_chap_g7 <span class="op">=</span> (np.array(W_chap_g7)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    sigma_chap_ginibre <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_ginibre<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_ginibre))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    sigma_chap_poisson <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_poisson<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_poisson))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    sigma_chap_g7 <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_g7<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_g7))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    IC_ginibre_max, IC_ginibre_min <span class="op">=</span> p_chap_ginibre <span class="op">+</span> sigma_chap_ginibre, p_chap_ginibre <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_ginibre</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    IC_poisson_max, IC_poisson_min <span class="op">=</span> p_chap_poisson <span class="op">+</span> sigma_chap_poisson, p_chap_poisson <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_poisson</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    IC_g7_max, IC_g7_min <span class="op">=</span> p_chap_g7 <span class="op">+</span> sigma_chap_g7, p_chap_g7 <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_g7</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [list_r, IC_ginibre_min, IC_ginibre_max, IC_poisson_min, IC_poisson_max, IC_g7_min, IC_g7_max]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#fig-simulation" class="quarto-xref">Figure&nbsp;3</a> shows the results of the simulations, where we compare the confidence intervals of the poisson process with the Ginibre process and the <span class="math inline">0.7</span>-Ginibre process, using first the central cell and then the five central cells.</p>
<div id="fig-simulation" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-simulation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./figures/simulation.png" height="500" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-simulation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Simulation results using the central cell (up) and the five central cells (down).
</figcaption>
</figure>
</div>
<p>The limitation of the statistical approach using only the central cell is made visible by the presence of some overlap between the confidence intervals of the Poisson process and that of the <span class="math inline">0.7</span>-Ginibre process. Consequently, in specific cases, it may not be possible to determine the true nature of some processes based on this statistical test. On the other hand, if we average the ratio of the five most central cells (the cells whose centers are the closest to the origin), there is no longer an overlap among the various curves.</p>
<p>This approach shows that the chosen ratio variable represents a good repulsion criterion. On the other hand, our objective is to decide for a single map which model is the most pertinent, and that cannot be done by a frequentist approach. This is what motivated us to use a ML method.</p>
</section>
<section id="machine-learning-approach" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="machine-learning-approach"><span class="header-section-number">3.2</span> Machine Learning approach</h3>
<p>In this approach, we will use the same circular domain with <span class="math inline">N</span> points as in the statistical approach. Since the repulsion is not sensitive to scaling, we normalize the radius to <span class="math inline">R=\sqrt{N}</span>. This is due to the fact that a cloud drawn from a Ginibre point process of intensity <span class="math inline">1</span> with <span class="math inline">N</span> points occupies roughly a disk with this radius. We begin by generating the data of the Ginibre process, the <span class="math inline">0.7</span>-Ginibre process and the poisson process on which we will train the classification model, which is a Logistic Regression Classifier. Using only the central cell (respectively the five most central cells), the initial variables in our database consist of the surface and perimeter of the central cell (respectively surfaces and perimeters of the five central cells) of each generated sample, along with a binary variable that takes the value <span class="math inline">1</span> if the process is repulsive and <span class="math inline">0</span> otherwise. Subsequently, we add the ratio variable <span class="math inline">\frac{4 \pi S}{P^2}</span> of the central cell (respectively the five ratios of the five central cells) to provide the classification model with additional information on which to base its predictions. The output of the classifier is a composite score based on some statistics of the point process, tuned to discriminate between a Poisson process and a repulsive point process.</p>
<div id="99fae4bb" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dataframe_1cell(N, observations):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(beta_ginibre(N, <span class="fl">0.7</span>, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'process'</span>])</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_1cell(N, observations):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(ginibre(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'process'</span>])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dataframe_5cells(N, observations):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(beta_ginibre(N, <span class="fl">0.7</span>, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'S2'</span>, <span class="st">'S3'</span>, <span class="st">'S4'</span>, <span class="st">'S5'</span>, <span class="st">'P1'</span>, <span class="st">'P2'</span>, <span class="st">'P3'</span>, <span class="st">'P4'</span>, <span class="st">'P5'</span>, <span class="st">'process'</span>])</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_5cells(N, observations):</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(ginibre(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'S2'</span>, <span class="st">'S3'</span>, <span class="st">'S4'</span>, <span class="st">'S5'</span>, <span class="st">'P1'</span>, <span class="st">'P2'</span>, <span class="st">'P3'</span>, <span class="st">'P4'</span>, <span class="st">'P5'</span>, <span class="st">'process'</span>])</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As the generation of data requires considerable execution time, we will prepare the data locally (using the previous code), by generating, for each classification, a sample of <span class="math inline">5000</span> observations (<span class="math inline">2500</span> repulsive and <span class="math inline">2500</span> non-repulsive) of <span class="math inline">N = 50</span> points. Then we read them directly as follows:</p>
<div id="780e05f3" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_1 <span class="op">=</span> pd.read_csv(<span class="st">'data/beta_ginibre_1cell.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ginibre_data_1 <span class="op">=</span> pd.read_csv(<span class="st">'data/ginibre_1cell.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_2 <span class="op">=</span> pd.read_csv(<span class="st">'data/beta_ginibre_5cells.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ginibre_data_2 <span class="op">=</span> pd.read_csv(<span class="st">'data/ginibre_5cells.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here is an example of the data created of configurations of <span class="math inline">0.7</span>-Ginibre and poisson processes with one cell:</p>
<div id="23a2bea0" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_1.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">S1</th>
<th data-quarto-table-cell-role="th">P1</th>
<th data-quarto-table-cell-role="th">R1</th>
<th data-quarto-table-cell-role="th">process</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>3.282609</td>
<td>6.851499</td>
<td>0.878735</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>3.229371</td>
<td>7.052515</td>
<td>0.815905</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>5.542461</td>
<td>9.335383</td>
<td>0.799187</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>3.409986</td>
<td>8.318448</td>
<td>0.619267</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>4.336329</td>
<td>8.748695</td>
<td>0.711944</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Before starting the model’s training using the data generated, we will scale the data in order to avoir the concern of overfitting. Here is an example of the scaling of the previous data:</p>
<div id="95be4123" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>b_ginibre_1 <span class="op">=</span> beta_ginibre_data_1.copy()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> beta_ginibre_data_1.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    b_ginibre_1[col] <span class="op">=</span> (b_ginibre_1[col] <span class="op">-</span> b_ginibre_1[col].mean()) <span class="op">/</span> b_ginibre_1[col].std()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>ginibre_1 <span class="op">=</span> ginibre_data_1.copy()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ginibre_data_1.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    ginibre_1[col] <span class="op">=</span> (ginibre_1[col] <span class="op">-</span> ginibre_1[col].mean()) <span class="op">/</span> ginibre_1[col].std()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>b_ginibre_2 <span class="op">=</span> beta_ginibre_data_2.copy()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> beta_ginibre_data_2.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    b_ginibre_2[col] <span class="op">=</span> (b_ginibre_2[col] <span class="op">-</span> b_ginibre_2[col].mean()) <span class="op">/</span> b_ginibre_2[col].std()</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>ginibre_2 <span class="op">=</span> ginibre_data_2.copy()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ginibre_data_2.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    ginibre_2[col] <span class="op">=</span> (ginibre_2[col] <span class="op">-</span> ginibre_2[col].mean()) <span class="op">/</span> ginibre_2[col].std()</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>b_ginibre_1.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">S1</th>
<th data-quarto-table-cell-role="th">P1</th>
<th data-quarto-table-cell-role="th">R1</th>
<th data-quarto-table-cell-role="th">process</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-0.290349</td>
<td>-0.584119</td>
<td>1.447490</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-0.326183</td>
<td>-0.439422</td>
<td>0.661112</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1.230698</td>
<td>1.203856</td>
<td>0.451857</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>-0.204615</td>
<td>0.471835</td>
<td>-1.800031</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.418882</td>
<td>0.781540</td>
<td>-0.640083</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Now that the data is gathered, we will train the Logistic Regression model using the baseline model, i.e.&nbsp;all the hyperparameters’ values are taken as defaults, (a grid search can be used later in order to select the optimal hyperparameters). Other classification models (Random Forest, Support Vector Machine and XGBoost) have been tested but did not yield more significant results than the chosen classifier. We split each data to a train data and test data in order to see the model’s accuracy before testing it on the cartoradio data.</p>
<div id="5ed769a2" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report, roc_curve, roc_auc_score</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Useful function for evaluating our model:</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model_Evaluate(model, x_tt, y_tt):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    y_pred <span class="op">=</span> model.predict(x_tt)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(classification_report(y_tt, y_pred))</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    cf_matrix <span class="op">=</span> confusion_matrix(y_tt, y_pred)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    categories  <span class="op">=</span> [<span class="st">'Negative'</span>,<span class="st">'Positive'</span>]</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    group_names <span class="op">=</span> [<span class="st">'True Neg'</span>,<span class="st">'False Pos'</span>, <span class="st">'False Neg'</span>,<span class="st">'True Pos'</span>]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    group_percentages <span class="op">=</span> [<span class="st">'</span><span class="sc">{0:.2%}</span><span class="st">'</span>.<span class="bu">format</span>(value) <span class="cf">for</span> value <span class="kw">in</span> cf_matrix.flatten() <span class="op">/</span> np.<span class="bu">sum</span>(cf_matrix)]</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>v1<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>v2<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> v1, v2 <span class="kw">in</span> <span class="bu">zip</span>(group_names,group_percentages)]</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.asarray(labels).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    logit_roc_auc <span class="op">=</span> roc_auc_score(y_tt, model.predict(x_tt))</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    fpr, tpr, thresholds <span class="op">=</span> roc_curve(y_tt, model.predict_proba(x_tt)[:,<span class="dv">1</span>])</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adds subplot on position 1</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">121</span>)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    sns.heatmap(cf_matrix, annot <span class="op">=</span> labels, cmap <span class="op">=</span> <span class="st">'Blues'</span>,fmt <span class="op">=</span> <span class="st">''</span>, xticklabels <span class="op">=</span> categories, yticklabels <span class="op">=</span> categories)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">"Confusion Matrix"</span>, fontdict <span class="op">=</span> font)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Predicted values'</span>, ylabel<span class="op">=</span><span class="st">'Actual values'</span>)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adds subplot on position 2</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">122</span>)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    ax.plot(fpr, tpr, label<span class="op">=</span><span class="st">'area = </span><span class="sc">%0.2f</span><span class="st">'</span> <span class="op">%</span> logit_roc_auc)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    ax.plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>],<span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Standard'</span>)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim([<span class="op">-</span><span class="fl">0.02</span>, <span class="fl">1.02</span>])</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim([<span class="fl">0.0</span>, <span class="fl">1.05</span>])</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    thresholds_rounded <span class="op">=</span> [<span class="bu">round</span>(num, <span class="dv">1</span>) <span class="cf">for</span> num <span class="kw">in</span> thresholds]</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>]:</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> threshold <span class="kw">in</span> thresholds_rounded:</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> thresholds_rounded.index(threshold)</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>            ax.annotate(threshold, (fpr[index], tpr[index]))</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'Receiver Operating Characteristic (ROC)'</span>, fontdict <span class="op">=</span> font)</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'False Positive Rate (1-specificity)'</span>, ylabel<span class="op">=</span><span class="st">'True Positive Rate (sensitivity)'</span>)</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    ax.legend(loc<span class="op">=</span><span class="st">"lower right"</span>)</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    ax.grid()</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here are the results of the classification using each data: - <span class="math inline">0.7</span>-Ginibre Vs Poisson using the central cell:</p>
<div id="d3e96ba0" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>beta_X1 <span class="op">=</span> b_ginibre_1[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]].values</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>beta_y1 <span class="op">=</span> b_ginibre_1[<span class="st">'process'</span>].values</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>beta_X1_train, beta_X1_test, beta_y1_train, beta_y1_test <span class="op">=</span> train_test_split(beta_X1, beta_y1, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>beta_LR1 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>beta_LR1.fit(beta_X1_train, beta_y1_train)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>model_Evaluate(beta_LR1, beta_X1_test, beta_y1_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>              precision    recall  f1-score   support

           0       0.62      0.59      0.60       728
           1       0.63      0.66      0.64       772

    accuracy                           0.62      1500
   macro avg       0.62      0.62      0.62      1500
weighted avg       0.62      0.62      0.62      1500
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="published_202401_adrat_repulsion_files/figure-html/cell-10-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Ginibre Vs Poisson using the central cell:</li>
</ul>
<div id="209cceec" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> ginibre_1[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]].values</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> ginibre_1[<span class="st">'process'</span>].values</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>X1_train, X1_test, y1_train, y1_test <span class="op">=</span> train_test_split(X1, y1, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>LR1 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>LR1.fit(X1_train, y1_train)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>model_Evaluate(LR1, X1_test, y1_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>              precision    recall  f1-score   support

           0       0.72      0.62      0.67       728
           1       0.68      0.77      0.73       772

    accuracy                           0.70      1500
   macro avg       0.70      0.70      0.70      1500
weighted avg       0.70      0.70      0.70      1500
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="published_202401_adrat_repulsion_files/figure-html/cell-11-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><span class="math inline">0.7</span>-Ginibre Vs Poisson using the five central cells:</li>
</ul>
<div id="f2d07a31" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>beta_X2 <span class="op">=</span> b_ginibre_2[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]].values</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>beta_y2 <span class="op">=</span> b_ginibre_2[<span class="st">'process'</span>].values</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>beta_X2_train, beta_X2_test, beta_y2_train, beta_y2_test <span class="op">=</span> train_test_split(beta_X2, beta_y2, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>beta_LR2 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>beta_LR2.fit(beta_X2_train, beta_y2_train)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>model_Evaluate(beta_LR2, beta_X2_test, beta_y2_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>              precision    recall  f1-score   support

           0       0.74      0.68      0.71       728
           1       0.72      0.77      0.74       772

    accuracy                           0.73      1500
   macro avg       0.73      0.72      0.72      1500
weighted avg       0.73      0.73      0.73      1500
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="published_202401_adrat_repulsion_files/figure-html/cell-12-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Ginibre Vs Poisson using the five central cells:</li>
</ul>
<div id="eebe1aa8" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> ginibre_2[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]].values</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> ginibre_2[<span class="st">'process'</span>].values</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>X2_train, X2_test, y2_train, y2_test <span class="op">=</span> train_test_split(X2, y2, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>LR2 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>LR2.fit(X2_train, y2_train)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>model_Evaluate(LR2, X2_test, y2_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>              precision    recall  f1-score   support

           0       0.87      0.81      0.84       728
           1       0.83      0.88      0.86       772

    accuracy                           0.85      1500
   macro avg       0.85      0.85      0.85      1500
weighted avg       0.85      0.85      0.85      1500
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="published_202401_adrat_repulsion_files/figure-html/cell-13-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We can notice that our model’s accuracy when using the central cell is approximately <span class="math inline">70\%</span> for the Ginibre and Poisson processes classification. However, when considering the first five central cells, we achieve an accuracy of <span class="math inline">85 \%</span>, a result consistent with our statistical approach. This is because with the five cells, the model has access to more information about the nature of the sample, increasing the likelihood of successful sample classification by taking into account the surface areas and perimeters of the first five central cells.</p>
</section>
<section id="cartoradio-data-tests" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="cartoradio-data-tests"><span class="header-section-number">3.3</span> Cartoradio data Tests</h3>
<p>Cartoradio data is a set of configurations of some mobile phone base stations in Paris. The goal is to decide from the classification model already used, whether the configuration do present some repulsion. serait The initial data (positions of the antennas) cover a large area of the city of Paris (see <a href="#fig-cartoradio" class="quarto-xref">Figure&nbsp;4</a> (right)) With a real dataset, we often encounter the problem of heterogeneity between the different parts of the configurations since they depend on the topology of the space in which the antennas are placed.</p>
<p>To cope with this problem, we extract from each configuration a representative sample similar to the type of training data so that the tests make sense. <a href="#fig-cartoradio" class="quarto-xref">Figure&nbsp;4</a> (left) shows a sample extracted from a given configuration.</p>
<div id="fig-cartoradio" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cartoradio-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./figures/cartoradio.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cartoradio-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: On the left, Initial cartoradio configuration. On the right, Sample extracted from it and scaled.
</figcaption>
</figure>
</div>
<p>In the following, we read the cartoradio data directly from the “cartoradio_data.csv” file, then we add the variables that represent the ratio of the first five central cell and finally we scale the data. Here is the final (scaled) data on which we will test our model.</p>
<div id="35e1f5aa" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>cartoradio <span class="op">=</span> pd.read_csv(<span class="st">'data/cartoradio_data.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R1'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A1<span class="op">/</span>(cartoradio.P1)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R2'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A2<span class="op">/</span>(cartoradio.P2)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R3'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A3<span class="op">/</span>(cartoradio.P3)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R4'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A4<span class="op">/</span>(cartoradio.P4)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R5'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A5<span class="op">/</span>(cartoradio.P5)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>cartoradio.rename(columns<span class="op">=</span>{<span class="st">'A1'</span>: <span class="st">'S1'</span>, <span class="st">'A2'</span>: <span class="st">'S2'</span>, <span class="st">'A3'</span>:<span class="st">'S3'</span>, <span class="st">'A4'</span>:<span class="st">'S4'</span>, <span class="st">'A5'</span>:<span class="st">'S5'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>cartoradio <span class="op">=</span> cartoradio[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]]</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled <span class="op">=</span> cartoradio.copy()</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cartoradio.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    cartoradio_scaled[col] <span class="op">=</span> (cartoradio_scaled[col] <span class="op">-</span> cartoradio_scaled[col].mean()) <span class="op">/</span> cartoradio_scaled[col].std()</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled_1 <span class="op">=</span> cartoradio_scaled[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]]</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">S1</th>
<th data-quarto-table-cell-role="th">P1</th>
<th data-quarto-table-cell-role="th">R1</th>
<th data-quarto-table-cell-role="th">S2</th>
<th data-quarto-table-cell-role="th">P2</th>
<th data-quarto-table-cell-role="th">R2</th>
<th data-quarto-table-cell-role="th">S3</th>
<th data-quarto-table-cell-role="th">P3</th>
<th data-quarto-table-cell-role="th">R3</th>
<th data-quarto-table-cell-role="th">S4</th>
<th data-quarto-table-cell-role="th">P4</th>
<th data-quarto-table-cell-role="th">R4</th>
<th data-quarto-table-cell-role="th">S5</th>
<th data-quarto-table-cell-role="th">P5</th>
<th data-quarto-table-cell-role="th">R5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>0.666867</td>
<td>0.552371</td>
<td>0.771643</td>
<td>-1.320617</td>
<td>-0.826125</td>
<td>-0.776361</td>
<td>-0.096326</td>
<td>-0.168613</td>
<td>0.404993</td>
<td>-0.669259</td>
<td>-0.213674</td>
<td>-1.681895</td>
<td>-0.308449</td>
<td>0.204442</td>
<td>0.710274</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-0.671167</td>
<td>-0.539183</td>
<td>-0.749317</td>
<td>0.190101</td>
<td>0.256283</td>
<td>-0.237297</td>
<td>0.631242</td>
<td>0.372228</td>
<td>1.268942</td>
<td>-1.348825</td>
<td>-1.325250</td>
<td>-1.007578</td>
<td>0.554746</td>
<td>0.445616</td>
<td>0.792127</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-0.217555</td>
<td>-0.375224</td>
<td>0.929404</td>
<td>0.020793</td>
<td>-0.495321</td>
<td>1.305963</td>
<td>-1.264007</td>
<td>-1.425377</td>
<td>-0.384128</td>
<td>0.778718</td>
<td>0.508199</td>
<td>1.288062</td>
<td>-0.540157</td>
<td>-0.839995</td>
<td>0.838547</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0.022384</td>
<td>0.160723</td>
<td>-0.473342</td>
<td>0.718430</td>
<td>0.472801</td>
<td>0.225675</td>
<td>-0.191550</td>
<td>-0.088225</td>
<td>-0.237366</td>
<td>0.982122</td>
<td>0.780987</td>
<td>1.037943</td>
<td>-0.600881</td>
<td>-1.105307</td>
<td>0.877342</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2.098913</td>
<td>1.686911</td>
<td>1.622808</td>
<td>1.381928</td>
<td>1.424882</td>
<td>-0.729521</td>
<td>1.978979</td>
<td>1.785494</td>
<td>0.952267</td>
<td>-0.502795</td>
<td>-0.128419</td>
<td>-1.289489</td>
<td>-1.050843</td>
<td>-1.077248</td>
<td>0.791146</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>Here are the results of the tests on the cartoradio data using each model already trained, showing the classification value and its probability for each observation.</p>
<ul>
<li><span class="math inline">0.7</span>-Ginibre Vs Poisson using the central cell:</li>
</ul>
<div id="70c6d4cb" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, beta_LR1.predict(np.array(cartoradio_scaled_1)))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, beta_LR1.predict_proba(np.array(cartoradio_scaled_1)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classification results: [0 0 1 0 0 0 0 1 1 1]
Classification probabilities:
 [[0.50901223 0.49098777]
 [0.50682086 0.49317914]
 [0.32929348 0.67070652]
 [0.5688858  0.4311142 ]
 [0.70307381 0.29692619]
 [0.82600168 0.17399832]
 [0.59522974 0.40477026]
 [0.48553916 0.51446084]
 [0.26526311 0.73473689]
 [0.32029901 0.67970099]]</code></pre>
</div>
</div>
<ul>
<li>Ginibre Vs Poisson using the central cell:</li>
</ul>
<div id="1dd98e96" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, LR1.predict(np.array(cartoradio_scaled_1)))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, LR1.predict_proba(np.array(cartoradio_scaled_1)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classification results: [0 0 1 0 0 0 0 1 1 1]
Classification probabilities:
 [[0.53920106 0.46079894]
 [0.51723198 0.48276802]
 [0.21819289 0.78180711]
 [0.63278587 0.36721413]
 [0.86607864 0.13392136]
 [0.94845955 0.05154045]
 [0.6786939  0.3213061 ]
 [0.47850291 0.52149709]
 [0.13669341 0.86330659]
 [0.20399197 0.79600803]]</code></pre>
</div>
</div>
<p>It can be noted that the classification results using only the central cell are not significant enough. This is largely due to the low accuracy of the model used with the central cell, which is normal since the data does not contain enough variables for the model’s training.</p>
<ul>
<li><span class="math inline">0.7</span>-Ginibre Vs Poisson using the five central cell:</li>
</ul>
<div id="05c17948" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, beta_LR2.predict(np.array(cartoradio_scaled)))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, beta_LR2.predict_proba(np.array(cartoradio_scaled)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classification results: [1 0 1 0 0 0 1 1 1 1]
Classification probabilities:
 [[0.09769033 0.90230967]
 [0.52006646 0.47993354]
 [0.26792874 0.73207126]
 [0.64697624 0.35302376]
 [0.78613725 0.21386275]
 [0.8428339  0.1571661 ]
 [0.26825798 0.73174202]
 [0.23098875 0.76901125]
 [0.17152636 0.82847364]
 [0.07711947 0.92288053]]</code></pre>
</div>
</div>
<ul>
<li>Ginibre Vs Poisson using the five central cell:</li>
</ul>
<div id="083bba3b" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, LR2.predict(np.array(cartoradio_scaled)))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, LR2.predict_proba(np.array(cartoradio_scaled)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classification results: [1 0 1 0 0 0 1 1 1 1]
Classification probabilities:
 [[0.02251152 0.97748848]
 [0.51505581 0.48494419]
 [0.22926168 0.77073832]
 [0.83308711 0.16691289]
 [0.97698632 0.02301368]
 [0.96058932 0.03941068]
 [0.28009441 0.71990559]
 [0.09008345 0.90991655]
 [0.08552465 0.91447535]
 [0.01824254 0.98175746]]</code></pre>
</div>
</div>
<p>In contrast, the results found using the five central cells are much better, the majority of configurations are classified as repulsive. Regarding the configurations classified as non-repulsive by our model, we can say that this comes down to one of the following two reasons: - As long as we are dealing with real data, these samples may be a non-repulsive ones and the results are actually coherent. - It is sure that the accuracy of our models is high, but we may have some classification errors, which means that even if the configuration is repulsive, the model decides that it is not.</p>
</section>
</section>
<section id="conclusion" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">4</span> Conclusion</h2>
<p>In this paper it has been shown numerically (based on the theoretical results in <span class="citation" data-cites="goldman_palm_2010">Goldman (<a href="#ref-goldman_palm_2010" role="doc-biblioref">2010</a>)</span>) that Voronoi cells represent an effective means for determining the nature of repulsion of a configuration (repulsive or not), and this by creating a database of various configurations and extracting the areas and perimeters of the Voronoi cells in order to use them as input to the classification model described earlier.</p>
<p>Once the model is trained and tested on the data created, it is tested after that on real data, which are the positions of a mobile phone base stations in Paris. Visually, we can easily say that these configurations are repulsive, which we have confirmed for the majority of these configurations by testing them by the previously trained model, especially the one classifying Ginibre and poisson processes using the first five central cells.</p>
<!-- -->

</section>
<section id="bibliography" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliography</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-ANFR" class="csl-entry" role="listitem">
ANFR. n.d. <span>“Https://Www.cartoradio.fr.”</span> <a href="https://www.cartoradio.fr">https://www.cartoradio.fr</a>.
</div>
<div id="ref-BaccelliStochasticGeometryWireless2008" class="csl-entry" role="listitem">
Baccelli, F., and B. Błaszczyszyn. 2008. <span>“Stochastic <span>Geometry</span> and <span>Wireless Networks</span>: <span>Volume I Theory</span>.”</span> <em>Foundations and Trends in Networking</em> 3 (34): 249–449. <a href="https://doi.org/10.1561/1300000006">https://doi.org/10.1561/1300000006</a>.
</div>
<div id="ref-BaccelliStochasticGeometryWireless2009" class="csl-entry" role="listitem">
———. 2009. <span>“Stochastic <span>Geometry</span> and <span>Wireless Networks</span>: <span>Volume II Applications</span>.”</span> <em>Foundations and Trends in Networking</em> 4 (12): 1–312. <a href="https://doi.org/10.1561/1300000026">https://doi.org/10.1561/1300000026</a>.
</div>
<div id="ref-Daley2003" class="csl-entry" role="listitem">
Daley, D. J., and D. Vere-Jones. 2003. <em>An Introduction to the Theory of Point Processes. <span>V</span>ol. <span>I</span></em>. Second. Probability and Its Applications (New York). Springer-Verlag, New York.
</div>
<div id="ref-MR4279876" class="csl-entry" role="listitem">
Decreusefond, Laurent, and Guillaume Moroz. 2021. <span>“Optimal Transport Between Determinantal Point Processes and Application to Fast Simulation.”</span> <em>Mod. Stoch. Theory Appl.</em> 8 (2): 209–37.
</div>
<div id="ref-Decreusefond_2015" class="csl-entry" role="listitem">
Decreusefond, L., I. Flint, and A. Vergne. 2015. <span>“A Note on the Simulation of the <span>G</span>inibre Point Process.”</span> <em>Journal of Applied Probability</em> 52 (04): 1003–12. <a href="https://doi.org/10.1239/jap/1450802749">https://doi.org/10.1239/jap/1450802749</a>.
</div>
<div id="ref-DecreusefondAsymptoticssuperpositionpoint2015" class="csl-entry" role="listitem">
Decreusefond, L., and A. Vasseur. 2015. <span>“Asymptotics of Superposition of Point Processes.”</span> In <em>Geometry of <span>Science Information</span></em>. Palaiseau.
</div>
<div id="ref-Deng2014" class="csl-entry" role="listitem">
Deng, Na, Wuyang Zhou, and Martin Haenggi. 2015. <span>“The Ginibre Point Process as a Model for Wireless Networks with Repulsion.”</span> <em>IEEE Transactions on Wireless Communications</em> 14 (1). <a href="https://arxiv.org/abs/1401.3677v1">https://arxiv.org/abs/1401.3677v1</a>.
</div>
<div id="ref-goldman_palm_2010" class="csl-entry" role="listitem">
Goldman, André. 2010. <span>“The <span>Palm</span> Measure and the <span>Voronoi</span> Tessellation for the <span>Ginibre</span> Process.”</span> <em>The Annals of Applied Probability</em> 20 (1): 90–128. <a href="https://doi.org/10.1214/09-AAP620">https://doi.org/10.1214/09-AAP620</a>.
</div>
<div id="ref-Gomez2015" class="csl-entry" role="listitem">
Gomez, Jean-Sébastien, Aurélien Vasseur, Anaı̈s Vergne, Philippe Martins, Laurent Decreusefond, and Wei Chen. 2015. <span>“A Case Study on Regularity in Cellular Network Deployment.”</span> <em>IEEE Wireless Communications Letters, IEEE, 2015, Pp.4</em>, May. <a href="https://arxiv.org/abs/1505.06073v1">https://arxiv.org/abs/1505.06073v1</a>.
</div>
<div id="ref-HoughDeterminantalprocessesindependence2006" class="csl-entry" role="listitem">
Hough, J. B., M. Krishnapur, Y. Peres, and B. Virág. 2006. <span>“Determinantal Processes and Independence.”</span> <em>Probability Surveys</em> 3: 206–229 (electronic).
</div>
<div id="ref-Miyoshi2016" class="csl-entry" role="listitem">
Miyoshi, Naoto, and Tomoyuki Shirai. 2016. <span>“Spatial Modeling and Analysis of Cellular Networks Using the <span>G</span>inibre Point Process: A Tutorial.”</span> <em><span>IEICE</span> Transactions on Communications</em> E99.B (11): 2247–55. <a href="https://doi.org/10.1587/transcom.2016nei0001">https://doi.org/10.1587/transcom.2016nei0001</a>.
</div>
<div id="ref-Taylor2012" class="csl-entry" role="listitem">
Taylor, D. B., H. S. Dhillon, T. D. Novlan, and J. G. Andrews. 2012. <span>“Pairwise Interaction Processes for Modeling Cellular Network Topology.”</span> In <em>Globecom</em>. <a href="https://doi.org/10.1109/glocom.2012.6503831">https://doi.org/10.1109/glocom.2012.6503831</a>.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{adrat2024,
  author = {Adrat, Hamza and Decreusefond, Laurent},
  publisher = {Société Française de Statistique},
  title = {Point {Process} {Discrimination} {According} to {Repulsion}},
  journal = {Computo},
  date = {2024-01-25},
  url = {https://computo.sfds.asso.fr/published_202401_adrat_repulsion/},
  doi = {10.57750/3r07-aw28},
  issn = {2824-7795},
  langid = {en},
  abstract = {In numerous applications, cloud of points do seem to
    exhibit *repulsion* in the intuitive sense that there is no local
    cluster as in a Poisson process. Motivated by data coming from
    cellular networks, we devise a classification algorithm based on the
    form of the Voronoi cells. We show that, in the particular set of
    data we are given, we can retrieve some repulsiveness between
    antennas, which was expected for engineering reasons.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-adrat2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Adrat, Hamza, and Laurent Decreusefond. 2024. <span>“Point Process
Discrimination According to Repulsion.”</span> <em>Computo</em>,
January. <a href="https://doi.org/10.57750/3r07-aw28">https://doi.org/10.57750/3r07-aw28</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb27" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Point Process Discrimination According to Repulsion"</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">    - name: Hamza Adrat</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">      corresponding: true</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">      email: hamza.adrat@um6p.ma</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">      url: https://www.linkedin.com/in/hamza-adrat/</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">      orcid: 0009-0004-8155-3260</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">      affiliations:</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">        - name: Mohammed VI Polytechnic University</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">          department: EMINES - School of Industrial Management</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">          url: https://www.emines-ingenieur.org/</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - name: Laurent Decreusefond</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="co">      email: laurent.decreusefond@telecom-paris.fr</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co">      url: https://perso.telecom-paris.fr/~decreuse</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="co">      orcid: 0000-0002-8964-0957</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="co">      affiliations:</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="co">        - name: Telecom Paris</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co">          department: Computer Science</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="co">          url: https://telecom-paris.fr</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 01/25/2024</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="co"># description: |</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="co">#   This document provides a template based on the [`quarto`](https://quarto.org/) system for contributions to Computo, using the [`quarto journal extension`](https://github.com/computorg/computo-quarto-extension), the Jupyter kernel (Python user) and `venv+pip` to set-up the dependencies.</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a><span class="co">    In numerous applications, cloud of points do seem to exhibit *repulsion* in the intuitive sense that there is no local cluster as in a Poisson process. Motivated by data coming from cellular networks, we devise a classification algorithm based on the form of the Voronoi cells. We show that, in the particular set of data we are given, we can retrieve some repulsiveness between antennas, which was expected for engineering reasons.</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [classification, point process, repulsion]</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "10.57750/3r07-aw28"</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/published_202401_adrat_repulsion/</span></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "published_202401_adrat_repulsion/"</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> false # set to false once the build is running</span></span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a><span class="an">google-scholar:</span><span class="co"> true</span></span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> true # will be set to true once accepted</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-49"><a href="#cb27-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-50"><a href="#cb27-50" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb27-51"><a href="#cb27-51" aria-hidden="true" tabindex="-1"></a>In the performance analysis of cellular systems, the locations of antennas (or base stations) play a major role (see @BaccelliStochasticGeometryWireless2008). It is usually admitted that they can be modeled by a Poisson process. But the data which can be gathered from the Web site of the French National Agency of Radio Frequencies, Cartoradio, see @ANFR, tend to prove that this may not be the case. More precisely, if we look at the global picture of all antennas in Paris, we see features reminiscent of a Poisson process (local clusters for instance), see @fig-paris-orange (left). However, if we look closer and finer, by specifying a region and a frequency band, we see that the antennas locations do seem to exhibit some repulsion (see @fig-paris-orange, right picture).</span>
<span id="cb27-52"><a href="#cb27-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-53"><a href="#cb27-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-54"><a href="#cb27-54" aria-hidden="true" tabindex="-1"></a>:::{#fig-paris-orange}</span>
<span id="cb27-55"><a href="#cb27-55" aria-hidden="true" tabindex="-1"></a><span class="al">![](./figures/paris-orange.png)</span></span>
<span id="cb27-56"><a href="#cb27-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-57"><a href="#cb27-57" aria-hidden="true" tabindex="-1"></a>Left: Antennas in Paris. Right: Antennas in one frequency  band only.</span>
<span id="cb27-58"><a href="#cb27-58" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-59"><a href="#cb27-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-60"><a href="#cb27-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-61"><a href="#cb27-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-62"><a href="#cb27-62" aria-hidden="true" tabindex="-1"></a>In previous papers, point processes with repulsion have been used to model such systems <span class="co">[</span><span class="ot">@Deng2014;@Miyoshi2016;@Gomez2015</span><span class="co">]</span> for no reason but a mere resemblance between the pictures like the right picture in {numref}<span class="in">`paris-orange-fig`</span> and those obtained by simulating a point process with repulsion. The question is then to decide, given one sample of positions of base stations in a bounded domain, whether it is more likely to be modeled by a point process with repulsion or by a *neutral* point process, i.e. where the locations could be considered as coming from independent drawings of some identically distributed random variables. As we only have a single realization,  we cannot use frequency methods. Since the observation window is finite, we cannot either resort to estimates based on stationarity or ergodicity and  we must take care from the side effects.</span>
<span id="cb27-63"><a href="#cb27-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-64"><a href="#cb27-64" aria-hidden="true" tabindex="-1"></a>The rationale behind our work comes from @goldman_palm_2010. It is shown there that the Voronoi cells of the Ginibre point process (a particular point</span>
<span id="cb27-65"><a href="#cb27-65" aria-hidden="true" tabindex="-1"></a>process with repulsion, see below for the exact definition) are in some sense more regular (closer to a circle) than those of a Poisson process (see @eq-theorem-goldman in @thm-goldman). By simulation, this feature seems to persist for other point processes with repulsion, like Gibbs processes. In @Taylor2012, the surface of Voronoi cells is claimed to be a good discrepancy indicator between Poisson process and several processes with repulsion (Gibbs processes, Strauss processes with repulsion and the Geyer saturation model). For any of these models, we do not have any closed formula on the surface of the Voronoi cells so the procedure proposed in this paper is to simulate a large number of realizations of each of these processes and compute the empirical mean and variance of the Voronoi cells area. They obtain mixed conclusions as this sole indicator does not enable to rule out the Poisson hypothesis for many situations.</span>
<span id="cb27-66"><a href="#cb27-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-67"><a href="#cb27-67" aria-hidden="true" tabindex="-1"></a>Our contribution is to consider the ratio of the surface by the squared perimeter instead of the surface of the Voronoi cells alone. Actually, we can interpret</span>
<span id="cb27-68"><a href="#cb27-68" aria-hidden="true" tabindex="-1"></a>the result of @goldman_palm_2010 by saying that the Voronoi cells of a Ginibre point process are more circular than those of a Poisson point process. The isoperimetric inequality stands for any regular enough domain in the plane, $R = \frac{4 \pi S}{P^2}$ is less than $1$ and the equality is obtained for disks. It is thus sensible to think that the ratio $R$ will be closer to $1$ for repulsive processes than for neutral point processes. Following the procedure of @Taylor2012, we show that we get a much better indicator by using $R$ instead $S$ alone to discriminate between repulsive and neutral point processes.</span>
<span id="cb27-69"><a href="#cb27-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-70"><a href="#cb27-70" aria-hidden="true" tabindex="-1"></a>However, for the application we have in mind, which is to decide for one single map  which model is the most pertinent, we cannot use this criterion based on probability. That is why we resort to an ML model. After several tries, we concluded that the most efficient algorithm was to use Logistic Regression. In a first step, we trained it on simulations of Ginibre and Poisson point processes. The advantage of the Ginibre process is that we have efficient algorithm to simulate it <span class="co">[</span><span class="ot">@MR4279876</span><span class="co">]</span> and it does not seem to alter the accuracy of our algorithm to use one single class of repulsive point process. We remarked that we obtain a much better discrimination by considering the mean value of $R$ for the five most central cells instead of just the most central one. We can even improve our discrimination rate by adding to the input vector the value of each of the five ratios.</span>
<span id="cb27-71"><a href="#cb27-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-72"><a href="#cb27-72" aria-hidden="true" tabindex="-1"></a>Furthermore, the repulsion in the Ginibre class of point processes can be also modulated by making a $\beta$-thinning (to weaken the repulsion) and then a $\sqrt{\beta}$-dilation (to keep the same intensity of points per surface unit) to obtain what is called a $\beta$-Ginibre. For $\beta=1$, we have the original Ginibre process and when $\beta$ goes to $0$, it tends in law to a Poisson process (see @DecreusefondAsymptoticssuperpositionpoint2015) so that we have a full scale of point processes with intermediate repulsion between $0$ and $1$. We show that our logistic regression algorithm can still accurately discriminate between Poisson and $\beta$-repulsive point processes for $\beta$ up to $0.7$.</span>
<span id="cb27-73"><a href="#cb27-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-74"><a href="#cb27-74" aria-hidden="true" tabindex="-1"></a>The paper is organized as follows. We first remind what is a Ginibre point process and the property of its Voronoi cells which motivates the sequel. Then two approaches are employed, one based on statistics and the other on machine learning, to classify the processes and compare their efficiencies and outcomes. Finally, tests are conducted on the Cartoradio data.</span>
<span id="cb27-75"><a href="#cb27-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-76"><a href="#cb27-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-77"><a href="#cb27-77" aria-hidden="true" tabindex="-1"></a><span class="fu">## Preliminaries</span></span>
<span id="cb27-78"><a href="#cb27-78" aria-hidden="true" tabindex="-1"></a>We consider finite point processes on a bounded window $E$. The law of a such a point process $N$ can be  characterized by its correlation functions (for</span>
<span id="cb27-79"><a href="#cb27-79" aria-hidden="true" tabindex="-1"></a>details we refer to @Daley2003<span class="co">[</span><span class="ot">Chapter 5</span><span class="co">]</span>). These are symmetric functions $(\rho_{k},k\ge 1)$ such that for any bounded function $f$, we can write:</span>
<span id="cb27-80"><a href="#cb27-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-81"><a href="#cb27-81" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-82"><a href="#cb27-82" aria-hidden="true" tabindex="-1"></a> \mathbb{E}\left<span class="co">[</span><span class="ot"> \sum_{\alpha \subset N} f(\alpha) \right</span><span class="co">]</span> = \sum_{k=1}^{+ \infty} \frac{1}{k!} \int_{E^k} f(<span class="sc">\{</span>x_1, \dots, x_k<span class="sc">\}</span>) \rho_{k}(x_1, \dots, x_k) \, d x_1 \dots d x_k .</span>
<span id="cb27-83"><a href="#cb27-83" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-84"><a href="#cb27-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-85"><a href="#cb27-85" aria-hidden="true" tabindex="-1"></a>Intuitively speaking, $\rho_{k}(x_{1}, \dots, x_{k}) \, d x_{1} \dots d x_{k}$ represents the probability to observe in $N$, at least $k$ points located around the</span>
<span id="cb27-86"><a href="#cb27-86" aria-hidden="true" tabindex="-1"></a>point $x_{j}$. For a Poisson point process of control measure $m(x) \, dx$, we have</span>
<span id="cb27-87"><a href="#cb27-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-88"><a href="#cb27-88" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-89"><a href="#cb27-89" aria-hidden="true" tabindex="-1"></a>\rho_{k}(x_{1}, \dots, x_{k}) = \prod_{j=1}^{k} m(x_{j}).</span>
<span id="cb27-90"><a href="#cb27-90" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-91"><a href="#cb27-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-92"><a href="#cb27-92" aria-hidden="true" tabindex="-1"></a>The **Ginibre point process**, restricted to $E=B(0,r)$, with intensity $\rho = \frac{\lambda}{\pi}$ (with $\lambda &gt; 0$) has correlation functions (see @Decreusefond_2015)</span>
<span id="cb27-93"><a href="#cb27-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-94"><a href="#cb27-94" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-95"><a href="#cb27-95" aria-hidden="true" tabindex="-1"></a>\rho_{k}(x_1, \dots, x_k) = \det(K(x_i, x_j), \; 1 \le i,j \le k)</span>
<span id="cb27-96"><a href="#cb27-96" aria-hidden="true" tabindex="-1"></a>$$ {#eq-correlation_functions_determinantal}</span>
<span id="cb27-97"><a href="#cb27-97" aria-hidden="true" tabindex="-1"></a>where $K$ is given by</span>
<span id="cb27-98"><a href="#cb27-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-99"><a href="#cb27-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-100"><a href="#cb27-100" aria-hidden="true" tabindex="-1"></a>K_r(x,y)=\sum_{j=1}^\infty \frac{\gamma(j+1,r^2)}{j!} \phi_j(x)\phi_j(\bar y)</span>
<span id="cb27-101"><a href="#cb27-101" aria-hidden="true" tabindex="-1"></a>$$ {#eq-main}</span>
<span id="cb27-102"><a href="#cb27-102" aria-hidden="true" tabindex="-1"></a>with</span>
<span id="cb27-103"><a href="#cb27-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-104"><a href="#cb27-104" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-105"><a href="#cb27-105" aria-hidden="true" tabindex="-1"></a>\phi_j(x) = \sqrt{\frac{\rho}{\gamma(j+1,r^2)}} \left(\sqrt{\lambda} x \right)^j \, e^{-\frac{\lambda}{2} |x|^2}</span>
<span id="cb27-106"><a href="#cb27-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-107"><a href="#cb27-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-108"><a href="#cb27-108" aria-hidden="true" tabindex="-1"></a>and $\gamma(n,x)$ is the lower incomplete Gamma function. The simulation of such a point process is a delicate matter, first solved in @HoughDeterminantalprocessesindependence2006. It remains costly because the algorithm contains complex calculations and some rejections. In order to fasten the procedure, an approximate algorithm, with error estimates, has been given in @MR4279876 (see the bibliography therein to get the URL of the Python code).</span>
<span id="cb27-109"><a href="#cb27-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-110"><a href="#cb27-110" aria-hidden="true" tabindex="-1"></a>For an at most denumerable set of points $<span class="sc">\{</span>x_{n}, \, n \ge 1<span class="sc">\}</span>$, the Voronoi cells are defined as the convex sets</span>
<span id="cb27-111"><a href="#cb27-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-112"><a href="#cb27-112" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-113"><a href="#cb27-113" aria-hidden="true" tabindex="-1"></a>\mathcal{C}(x_{i})=<span class="sc">\{</span>z \in \mathbb{C},\ |z-x_{i}|\le |z-x_{j}|  \text{ for all }j\neq i<span class="sc">\}</span>.</span>
<span id="cb27-114"><a href="#cb27-114" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-115"><a href="#cb27-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-116"><a href="#cb27-116" aria-hidden="true" tabindex="-1"></a>When the points are drawn from a point process, we thus have a collection of random closed sets. When the process under consideration is stationary with respect to translations, it is customary to define the typical law of a Voronoi cell as the law of the cell containing the origin of $\mathbb{R}^{2}$ when the point process is taken under its Palm distribution <span class="co">[</span><span class="ot">@goldman_palm_2010; @BaccelliStochasticGeometryWireless2009</span><span class="co">]</span>. It turns out that we know the Palm distribution of the Poisson process (which is itself) and of the Ginibre point process (the correlation functions are of the form @eq-correlation_functions_determinantal with $K$ being $K_{R}$ with the first term removed).</span>
<span id="cb27-117"><a href="#cb27-117" aria-hidden="true" tabindex="-1"></a>We denote by $\mathcal{C}_p$ (respectively $\mathcal{C}_{G}$) the typical cell of the Voronoi tessellation associated to a stationary Poisson process in $\mathbb{C}$  with</span>
<span id="cb27-118"><a href="#cb27-118" aria-hidden="true" tabindex="-1"></a>intensity $\lambda$ (respectively to the Ginibre point process of intensity $\rho$). One of the main theorems of @goldman_palm_2010 is the following.</span>
<span id="cb27-119"><a href="#cb27-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-120"><a href="#cb27-120" aria-hidden="true" tabindex="-1"></a>::: {#thm-goldman}</span>
<span id="cb27-121"><a href="#cb27-121" aria-hidden="true" tabindex="-1"></a>When $r \to 0,$</span>
<span id="cb27-122"><a href="#cb27-122" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb27-123"><a href="#cb27-123" aria-hidden="true" tabindex="-1"></a>\mathbb{E} \left<span class="co">[</span><span class="ot"> V(\mathcal{C}_{G} \cap B(0,r)) \right</span><span class="co">]</span> = \mathbb{E} \left<span class="co">[</span><span class="ot"> V(\mathcal{C}_p \cap B(0,r)) \right</span><span class="co">]</span> (1 + r^2 W + \circ(r^2))</span>
<span id="cb27-124"><a href="#cb27-124" aria-hidden="true" tabindex="-1"></a>$$ {#eq-theorem-goldman}</span>
<span id="cb27-125"><a href="#cb27-125" aria-hidden="true" tabindex="-1"></a>where $W$ is a positive random variable.</span>
<span id="cb27-126"><a href="#cb27-126" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-127"><a href="#cb27-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-128"><a href="#cb27-128" aria-hidden="true" tabindex="-1"></a>@thm-goldman shows that near the germs of the cells a more important part of the area is captured in the Ginibre–Voronoi tessellation than in the Poisson–Voronoi tessellation. This is an indication that the Voronoi cells of the Ginibre point process are more circular than those given by the Poisson process. This can be corroborated by simulation as shows @fig-voronoi.</span>
<span id="cb27-129"><a href="#cb27-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-130"><a href="#cb27-130" aria-hidden="true" tabindex="-1"></a>:::{#fig-voronoi}</span>
<span id="cb27-131"><a href="#cb27-131" aria-hidden="true" tabindex="-1"></a><span class="al">![](./figures/Voronoi.png)</span></span>
<span id="cb27-132"><a href="#cb27-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-133"><a href="#cb27-133" aria-hidden="true" tabindex="-1"></a>On the left, Voronoi cells associated to a realization of a Ginibre process. On the right, Voronoi cells associated to a realization of a Poisson process.</span>
<span id="cb27-134"><a href="#cb27-134" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-135"><a href="#cb27-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-136"><a href="#cb27-136" aria-hidden="true" tabindex="-1"></a>As we know that circles saturate the isoperimetric inequality, it is sensible to consider classification algorithms based on area and squared perimeter of Voronoi cells. In order to avoid side effects, we concentrate on the innermost cells of the observation window.</span>
<span id="cb27-137"><a href="#cb27-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-138"><a href="#cb27-138" aria-hidden="true" tabindex="-1"></a><span class="fu">## Classification of Cartoradio data</span></span>
<span id="cb27-139"><a href="#cb27-139" aria-hidden="true" tabindex="-1"></a>The Cartoradio web site contains the locations (in GPS coordinates) and other informations about all the antennas (or base stations) in metropolitan France for any operator, any frequency band and all generation of wireless systems (2G to 5G). The capacity of an antenna depends on its power and on the traffic demand it has to serve.  Outside metropolitan areas, the antennas are relatively scarce and located along the main roads to guarantee a large surface coverage (around 30 km$^2$). Hence there is no need to  construct models for these regions.  On the contrary, in big towns, the density of base stations is much higher to handle the traffic demand: An antenna covers around half a squared kilometer. This is  where the dimensioning problem do appear. One should have a sufficient number of antennas per unit of surface to transport all the traffic, on the other hand, base stations operating in a given frequency band cannot be to close to mitigate interference. This explains the right picture of @fig-paris-orange.</span>
<span id="cb27-140"><a href="#cb27-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-141"><a href="#cb27-141" aria-hidden="true" tabindex="-1"></a>When it comes to assess the type of point process we should consider in this situation, we cannot consider the city as a whole: the geography (notably the Seine river in Paris, the parks, etc.), the non uniformity of demands (the traffic is heavier aroung railway stations or touristic sites, for instance) which entails a higher density of antennas, ruin any kind of invariance a statistician could hope for. For instance, the lack of homogeneity prevents the use of traditional repulsion criteria, such as pair correlation. That means, we should restrict our expectations to local models of  the size of a district or a bit more. Since interference, which are the main annoyance to be dealt with, are a local phenomenon, working on a partial part of the whole domain is sufficient to predict the behavior and dimension a wireless network.</span>
<span id="cb27-142"><a href="#cb27-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-143"><a href="#cb27-143" aria-hidden="true" tabindex="-1"></a>In the following sections, we will use Python code that assumes that the following packages have been loaded:</span>
<span id="cb27-144"><a href="#cb27-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-147"><a href="#cb27-147" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-148"><a href="#cb27-148" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb27-149"><a href="#cb27-149" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb27-150"><a href="#cb27-150" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats</span>
<span id="cb27-151"><a href="#cb27-151" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> bernoulli</span>
<span id="cb27-152"><a href="#cb27-152" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.spatial <span class="im">import</span> Voronoi, ConvexHull</span>
<span id="cb27-153"><a href="#cb27-153" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb27-154"><a href="#cb27-154" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb27-155"><a href="#cb27-155" aria-hidden="true" tabindex="-1"></a>font <span class="op">=</span> {<span class="st">'family'</span>: <span class="st">'serif'</span>, <span class="st">'color'</span>:  <span class="st">'black'</span>, <span class="st">'weight'</span>: <span class="st">'normal'</span>, <span class="st">'size'</span>: <span class="dv">11</span>,}</span>
<span id="cb27-156"><a href="#cb27-156" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-157"><a href="#cb27-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-158"><a href="#cb27-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-159"><a href="#cb27-159" aria-hidden="true" tabindex="-1"></a><span class="fu">### Statistical approach</span></span>
<span id="cb27-160"><a href="#cb27-160" aria-hidden="true" tabindex="-1"></a>Given a circular domain with $N$ points, we want to decide whether the points exhibit repulsion or not. To do so, we will begin with a statistical approach, where we will first calculate, for Poisson processes as well as for Ginibre and $\beta$-Ginibre processes, the probability that the ratio $R = \frac{4 \pi S}{P^2}$ of the central cell is less than or equal to $r$, for values of $r$ ranging from $0$ to $1$. And then we  apply the same approach using the mean ratio of the five central cells. Finally, we will calculate $95$% confidence intervals for each of these processes.</span>
<span id="cb27-161"><a href="#cb27-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-162"><a href="#cb27-162" aria-hidden="true" tabindex="-1"></a>The following code illustrates the generation of various point samples and the calculation of the surface to squared perimeter ratios given the number of points $N$ and the parameter $\beta$ for $\beta$-Ginibre processes. The Ginibre and $\beta$-Ginibre processes are generated using the "sample" function given in the Python code of @MR4279876.</span>
<span id="cb27-163"><a href="#cb27-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-166"><a href="#cb27-166" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-167"><a href="#cb27-167" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> in_box(towers, bounding_box):</span>
<span id="cb27-168"><a href="#cb27-168" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.logical_and(np.logical_and(bounding_box[<span class="dv">0</span>] <span class="op">&lt;=</span> towers[:, <span class="dv">0</span>], towers[:, <span class="dv">0</span>] <span class="op">&lt;=</span> bounding_box[<span class="dv">1</span>]),</span>
<span id="cb27-169"><a href="#cb27-169" aria-hidden="true" tabindex="-1"></a>                          np.logical_and(bounding_box[<span class="dv">2</span>] <span class="op">&lt;=</span> towers[:, <span class="dv">1</span>], towers[:, <span class="dv">1</span>] <span class="op">&lt;=</span> bounding_box[<span class="dv">3</span>]))</span>
<span id="cb27-170"><a href="#cb27-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-171"><a href="#cb27-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-172"><a href="#cb27-172" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> voronoi(towers, bounding_box, N):</span>
<span id="cb27-173"><a href="#cb27-173" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select towers inside the bounding box</span></span>
<span id="cb27-174"><a href="#cb27-174" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> in_box(towers, bounding_box)</span>
<span id="cb27-175"><a href="#cb27-175" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mirror points</span></span>
<span id="cb27-176"><a href="#cb27-176" aria-hidden="true" tabindex="-1"></a>    points_center <span class="op">=</span> towers[i, :]</span>
<span id="cb27-177"><a href="#cb27-177" aria-hidden="true" tabindex="-1"></a>    points_left <span class="op">=</span> np.copy(points_center)</span>
<span id="cb27-178"><a href="#cb27-178" aria-hidden="true" tabindex="-1"></a>    points_left[:, <span class="dv">0</span>] <span class="op">=</span> bounding_box[<span class="dv">0</span>] <span class="op">-</span> (points_left[:, <span class="dv">0</span>] <span class="op">-</span> bounding_box[<span class="dv">0</span>])</span>
<span id="cb27-179"><a href="#cb27-179" aria-hidden="true" tabindex="-1"></a>    points_right <span class="op">=</span> np.copy(points_center)</span>
<span id="cb27-180"><a href="#cb27-180" aria-hidden="true" tabindex="-1"></a>    points_right[:, <span class="dv">0</span>] <span class="op">=</span> bounding_box[<span class="dv">1</span>] <span class="op">+</span> (bounding_box[<span class="dv">1</span>] <span class="op">-</span> points_right[:, <span class="dv">0</span>])</span>
<span id="cb27-181"><a href="#cb27-181" aria-hidden="true" tabindex="-1"></a>    points_down <span class="op">=</span> np.copy(points_center)</span>
<span id="cb27-182"><a href="#cb27-182" aria-hidden="true" tabindex="-1"></a>    points_down[:, <span class="dv">1</span>] <span class="op">=</span> bounding_box[<span class="dv">2</span>] <span class="op">-</span> (points_down[:, <span class="dv">1</span>] <span class="op">-</span> bounding_box[<span class="dv">2</span>])</span>
<span id="cb27-183"><a href="#cb27-183" aria-hidden="true" tabindex="-1"></a>    points_up <span class="op">=</span> np.copy(points_center)</span>
<span id="cb27-184"><a href="#cb27-184" aria-hidden="true" tabindex="-1"></a>    points_up[:, <span class="dv">1</span>] <span class="op">=</span> bounding_box[<span class="dv">3</span>] <span class="op">+</span> (bounding_box[<span class="dv">3</span>] <span class="op">-</span> points_up[:, <span class="dv">1</span>])</span>
<span id="cb27-185"><a href="#cb27-185" aria-hidden="true" tabindex="-1"></a>    points <span class="op">=</span> np.append(points_center,</span>
<span id="cb27-186"><a href="#cb27-186" aria-hidden="true" tabindex="-1"></a>                       np.append(np.append(points_left, points_right, axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb27-187"><a href="#cb27-187" aria-hidden="true" tabindex="-1"></a>                                 np.append(points_down, points_up, axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb27-188"><a href="#cb27-188" aria-hidden="true" tabindex="-1"></a>                                 axis<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb27-189"><a href="#cb27-189" aria-hidden="true" tabindex="-1"></a>                       axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb27-190"><a href="#cb27-190" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute Voronoi</span></span>
<span id="cb27-191"><a href="#cb27-191" aria-hidden="true" tabindex="-1"></a>    vor <span class="op">=</span> Voronoi(points)</span>
<span id="cb27-192"><a href="#cb27-192" aria-hidden="true" tabindex="-1"></a>    vor.filtered_points <span class="op">=</span> points_center</span>
<span id="cb27-193"><a href="#cb27-193" aria-hidden="true" tabindex="-1"></a>    vor.filtered_regions <span class="op">=</span> [vor.regions[vor.point_region[i]] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(points_center))]</span>
<span id="cb27-194"><a href="#cb27-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor</span>
<span id="cb27-195"><a href="#cb27-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-196"><a href="#cb27-196" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> central_area_perim(vor):</span>
<span id="cb27-197"><a href="#cb27-197" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ConvexHull(vor.vertices[vor.filtered_regions[<span class="dv">0</span>], :]).volume, ConvexHull(vor.vertices[vor.filtered_regions[<span class="dv">0</span>], :]).area</span>
<span id="cb27-198"><a href="#cb27-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-199"><a href="#cb27-199" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> area_perim(vor):</span>
<span id="cb27-200"><a href="#cb27-200" aria-hidden="true" tabindex="-1"></a>    area, perimeter <span class="op">=</span> [], []</span>
<span id="cb27-201"><a href="#cb27-201" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb27-202"><a href="#cb27-202" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(vor.filtered_regions) <span class="op">&gt;=</span> i:</span>
<span id="cb27-203"><a href="#cb27-203" aria-hidden="true" tabindex="-1"></a>            area.append(ConvexHull(vor.vertices[vor.filtered_regions[i], :]).volume)</span>
<span id="cb27-204"><a href="#cb27-204" aria-hidden="true" tabindex="-1"></a>            perimeter.append(ConvexHull(vor.vertices[vor.filtered_regions[i], :]).area)</span>
<span id="cb27-205"><a href="#cb27-205" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb27-206"><a href="#cb27-206" aria-hidden="true" tabindex="-1"></a>            area.append(np.mean(area))</span>
<span id="cb27-207"><a href="#cb27-207" aria-hidden="true" tabindex="-1"></a>            perimeter.append(np.mean(perimeter))</span>
<span id="cb27-208"><a href="#cb27-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> area, perimeter</span>
<span id="cb27-209"><a href="#cb27-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-210"><a href="#cb27-210" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ginibre(N, cells):</span>
<span id="cb27-211"><a href="#cb27-211" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> (np.sqrt(N)) <span class="op">;</span> precision <span class="op">=</span> <span class="dv">2</span><span class="op">**-</span><span class="dv">53</span> <span class="op">;</span> error <span class="op">=</span> <span class="va">False</span> <span class="op">;</span> quiet<span class="op">=</span><span class="va">True</span> <span class="op">;</span> output<span class="op">=</span><span class="va">None</span></span>
<span id="cb27-212"><a href="#cb27-212" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> [radius, N, kernels[<span class="st">'ginibre'</span>], precision, error, quiet, output]</span>
<span id="cb27-213"><a href="#cb27-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-214"><a href="#cb27-214" aria-hidden="true" tabindex="-1"></a>    sample_ginibre <span class="op">=</span> sample(<span class="op">*</span>args)</span>
<span id="cb27-215"><a href="#cb27-215" aria-hidden="true" tabindex="-1"></a>    X_ginibre, Y_ginibre <span class="op">=</span> sample_ginibre.real, sample_ginibre.imag</span>
<span id="cb27-216"><a href="#cb27-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-217"><a href="#cb27-217" aria-hidden="true" tabindex="-1"></a>    ginibre_points <span class="op">=</span> np.array([X_ginibre, Y_ginibre]).T</span>
<span id="cb27-218"><a href="#cb27-218" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((ginibre_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((ginibre_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb27-219"><a href="#cb27-219" aria-hidden="true" tabindex="-1"></a>    ginibre_points <span class="op">=</span> ginibre_points[indices]</span>
<span id="cb27-220"><a href="#cb27-220" aria-hidden="true" tabindex="-1"></a>    ginibre_vor <span class="op">=</span> voronoi(ginibre_points, (<span class="op">-</span>np.sqrt(N)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N)<span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>np.sqrt(N)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N)<span class="op">+</span><span class="fl">.1</span>), <span class="bu">len</span>(ginibre_points))</span>
<span id="cb27-221"><a href="#cb27-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-222"><a href="#cb27-222" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb27-223"><a href="#cb27-223" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(ginibre_vor)</span>
<span id="cb27-224"><a href="#cb27-224" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb27-225"><a href="#cb27-225" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(ginibre_vor)</span>
<span id="cb27-226"><a href="#cb27-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-227"><a href="#cb27-227" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb27-228"><a href="#cb27-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-229"><a href="#cb27-229" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beta_ginibre(N, beta, cells):</span>
<span id="cb27-230"><a href="#cb27-230" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> (np.sqrt(N)) <span class="op">;</span> precision <span class="op">=</span> <span class="dv">2</span><span class="op">**-</span><span class="dv">53</span> <span class="op">;</span> error <span class="op">=</span> <span class="va">False</span> <span class="op">;</span> quiet<span class="op">=</span><span class="va">True</span> <span class="op">;</span> output<span class="op">=</span><span class="va">None</span></span>
<span id="cb27-231"><a href="#cb27-231" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> [radius, N, kernels[<span class="st">'ginibre'</span>], precision, error, quiet, output]</span>
<span id="cb27-232"><a href="#cb27-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-233"><a href="#cb27-233" aria-hidden="true" tabindex="-1"></a>    sample_init <span class="op">=</span> sample(<span class="op">*</span>args)</span>
<span id="cb27-234"><a href="#cb27-234" aria-hidden="true" tabindex="-1"></a>    sample_beta_ginibre <span class="op">=</span> sample_init<span class="op">*</span>(bernoulli.rvs(beta, size<span class="op">=</span>N))</span>
<span id="cb27-235"><a href="#cb27-235" aria-hidden="true" tabindex="-1"></a>    sample_beta_ginibre <span class="op">=</span> np.array([a <span class="cf">for</span> a <span class="kw">in</span> sample_beta_ginibre <span class="cf">if</span> a <span class="op">!=</span> <span class="dv">0</span>])<span class="op">*</span>(np.sqrt(beta))</span>
<span id="cb27-236"><a href="#cb27-236" aria-hidden="true" tabindex="-1"></a>    X_beta_ginibre, Y_beta_ginibre <span class="op">=</span> sample_beta_ginibre.real, sample_beta_ginibre.imag</span>
<span id="cb27-237"><a href="#cb27-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-238"><a href="#cb27-238" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_points <span class="op">=</span> np.array([X_beta_ginibre, Y_beta_ginibre]).T</span>
<span id="cb27-239"><a href="#cb27-239" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((beta_ginibre_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((beta_ginibre_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb27-240"><a href="#cb27-240" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_points <span class="op">=</span> beta_ginibre_points[indices]</span>
<span id="cb27-241"><a href="#cb27-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-242"><a href="#cb27-242" aria-hidden="true" tabindex="-1"></a>    beta_ginibre_vor <span class="op">=</span> voronoi(beta_ginibre_points,</span>
<span id="cb27-243"><a href="#cb27-243" aria-hidden="true" tabindex="-1"></a>                               (<span class="op">-</span>np.sqrt(N<span class="op">*</span>beta)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N<span class="op">*</span>beta)<span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>np.sqrt(N<span class="op">*</span>beta)<span class="op">-</span><span class="fl">.1</span>, np.sqrt(N<span class="op">*</span>beta)<span class="op">+</span><span class="fl">.1</span>),</span>
<span id="cb27-244"><a href="#cb27-244" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">len</span>(beta_ginibre_points))</span>
<span id="cb27-245"><a href="#cb27-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-246"><a href="#cb27-246" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb27-247"><a href="#cb27-247" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(beta_ginibre_vor)</span>
<span id="cb27-248"><a href="#cb27-248" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb27-249"><a href="#cb27-249" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(beta_ginibre_vor)</span>
<span id="cb27-250"><a href="#cb27-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-251"><a href="#cb27-251" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb27-252"><a href="#cb27-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-253"><a href="#cb27-253" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> poisson(N, cells):</span>
<span id="cb27-254"><a href="#cb27-254" aria-hidden="true" tabindex="-1"></a>    radius <span class="op">=</span> np.sqrt(N)</span>
<span id="cb27-255"><a href="#cb27-255" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> scipy.stats.uniform.rvs(<span class="dv">0</span>,<span class="dv">1</span>,N)</span>
<span id="cb27-256"><a href="#cb27-256" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> radius <span class="op">*</span> np.sqrt(scipy.stats.uniform.rvs(<span class="dv">0</span>,<span class="dv">1</span>,N))</span>
<span id="cb27-257"><a href="#cb27-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-258"><a href="#cb27-258" aria-hidden="true" tabindex="-1"></a>    X_poisson, Y_poisson <span class="op">=</span> r<span class="op">*</span>np.cos(alpha), r<span class="op">*</span>np.sin(alpha)</span>
<span id="cb27-259"><a href="#cb27-259" aria-hidden="true" tabindex="-1"></a>    poisson_points <span class="op">=</span> np.array([X_poisson, Y_poisson]).T</span>
<span id="cb27-260"><a href="#cb27-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-261"><a href="#cb27-261" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.argsort((poisson_points[:,<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> ((poisson_points[:,<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb27-262"><a href="#cb27-262" aria-hidden="true" tabindex="-1"></a>    poisson_points <span class="op">=</span> poisson_points[indices]</span>
<span id="cb27-263"><a href="#cb27-263" aria-hidden="true" tabindex="-1"></a>    poisson_vor <span class="op">=</span> voronoi(poisson_points, (<span class="op">-</span>radius <span class="op">-</span><span class="fl">.1</span>, radius <span class="op">+</span><span class="fl">.1</span>, <span class="op">-</span>radius <span class="op">-</span><span class="fl">.1</span>, radius <span class="op">+</span><span class="fl">.1</span>), <span class="bu">len</span>(poisson_points))</span>
<span id="cb27-264"><a href="#cb27-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-265"><a href="#cb27-265" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cells<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb27-266"><a href="#cb27-266" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> central_area_perim(poisson_vor)</span>
<span id="cb27-267"><a href="#cb27-267" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb27-268"><a href="#cb27-268" aria-hidden="true" tabindex="-1"></a>        vor_area, vor_perim <span class="op">=</span> area_perim(poisson_vor)</span>
<span id="cb27-269"><a href="#cb27-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-270"><a href="#cb27-270" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vor_area, vor_perim</span>
<span id="cb27-271"><a href="#cb27-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-272"><a href="#cb27-272" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_ginibre(N, cells):</span>
<span id="cb27-273"><a href="#cb27-273" aria-hidden="true" tabindex="-1"></a>    G <span class="op">=</span> ginibre(N, cells)</span>
<span id="cb27-274"><a href="#cb27-274" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(G)[<span class="dv">0</span>]<span class="op">/</span>(np.array(G)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-275"><a href="#cb27-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-276"><a href="#cb27-276" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_beta_ginibre(N, beta, cells):</span>
<span id="cb27-277"><a href="#cb27-277" aria-hidden="true" tabindex="-1"></a>    beta_G <span class="op">=</span> beta_ginibre(N, beta, cells)</span>
<span id="cb27-278"><a href="#cb27-278" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(beta_G)[<span class="dv">0</span>]<span class="op">/</span>(np.array(beta_G)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-279"><a href="#cb27-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-280"><a href="#cb27-280" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ratio_poisson(N, cells):</span>
<span id="cb27-281"><a href="#cb27-281" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> poisson(N, cells)</span>
<span id="cb27-282"><a href="#cb27-282" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>np.array(P)[<span class="dv">0</span>]<span class="op">/</span>(np.array(P)[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-283"><a href="#cb27-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-284"><a href="#cb27-284" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>run <span class="op">-</span>i Moroz_dpp.py</span>
<span id="cb27-285"><a href="#cb27-285" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-286"><a href="#cb27-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-287"><a href="#cb27-287" aria-hidden="true" tabindex="-1"></a>The simulation algorithm provides a method for computing the quantity $\mathbb{P} \left( \frac{4 \pi S}{P^2} \le r \right)$ as a function of $r$ for the Ginibre processes (the same algorithm is applied to other processes as well). The Algorithm takes as input the number of points $N$, the number of experiences for the simulation $N_{exp}$ and the range of the variable $r$ as a list of values. Since the simulations require a lot of time to run, we are not going to attach the associated Python code, the latter is based on the algorithm described in the following Python code using the functions defined previously.</span>
<span id="cb27-288"><a href="#cb27-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-289"><a href="#cb27-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-290"><a href="#cb27-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-293"><a href="#cb27-293" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-294"><a href="#cb27-294" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulation(N, N_exp, list_r):</span>
<span id="cb27-295"><a href="#cb27-295" aria-hidden="true" tabindex="-1"></a>    W_chap_ginibre, W_chap_poisson, W_chap_g7 <span class="op">=</span> [], [], []</span>
<span id="cb27-296"><a href="#cb27-296" aria-hidden="true" tabindex="-1"></a>    l_ginibre, l_poisson, l_g7 <span class="op">=</span> [], [], []</span>
<span id="cb27-297"><a href="#cb27-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-298"><a href="#cb27-298" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N_exp):</span>
<span id="cb27-299"><a href="#cb27-299" aria-hidden="true" tabindex="-1"></a>        l_ginibre.append(ratio_ginibre(N))</span>
<span id="cb27-300"><a href="#cb27-300" aria-hidden="true" tabindex="-1"></a>        l_poisson.append(ratio_poisson(N))</span>
<span id="cb27-301"><a href="#cb27-301" aria-hidden="true" tabindex="-1"></a>        l_g7.append(ratio_beta_ginibre(N, <span class="fl">0.7</span>))</span>
<span id="cb27-302"><a href="#cb27-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-303"><a href="#cb27-303" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> list_r:</span>
<span id="cb27-304"><a href="#cb27-304" aria-hidden="true" tabindex="-1"></a>        W_chap_ginibre.append((np.array(l_ginibre) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb27-305"><a href="#cb27-305" aria-hidden="true" tabindex="-1"></a>        W_chap_poisson.append((np.array(l_poisson) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb27-306"><a href="#cb27-306" aria-hidden="true" tabindex="-1"></a>        W_chap_g7.append((np.array(l_g7) <span class="op">&lt;=</span> r)<span class="op">*</span><span class="dv">1</span>)</span>
<span id="cb27-307"><a href="#cb27-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-308"><a href="#cb27-308" aria-hidden="true" tabindex="-1"></a>    p_chap_ginibre <span class="op">=</span> (np.array(W_chap_ginibre)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-309"><a href="#cb27-309" aria-hidden="true" tabindex="-1"></a>    p_chap_poisson <span class="op">=</span> (np.array(W_chap_poisson)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-310"><a href="#cb27-310" aria-hidden="true" tabindex="-1"></a>    p_chap_g7 <span class="op">=</span> (np.array(W_chap_g7)).mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-311"><a href="#cb27-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-312"><a href="#cb27-312" aria-hidden="true" tabindex="-1"></a>    sigma_chap_ginibre <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_ginibre<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_ginibre))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb27-313"><a href="#cb27-313" aria-hidden="true" tabindex="-1"></a>    sigma_chap_poisson <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_poisson<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_poisson))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb27-314"><a href="#cb27-314" aria-hidden="true" tabindex="-1"></a>    sigma_chap_g7 <span class="op">=</span> (<span class="fl">1.96</span>)<span class="op">*</span>np.sqrt(p_chap_g7<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>p_chap_g7))<span class="op">/</span>(np.sqrt(N_exp))</span>
<span id="cb27-315"><a href="#cb27-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-316"><a href="#cb27-316" aria-hidden="true" tabindex="-1"></a>    IC_ginibre_max, IC_ginibre_min <span class="op">=</span> p_chap_ginibre <span class="op">+</span> sigma_chap_ginibre, p_chap_ginibre <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_ginibre</span>
<span id="cb27-317"><a href="#cb27-317" aria-hidden="true" tabindex="-1"></a>    IC_poisson_max, IC_poisson_min <span class="op">=</span> p_chap_poisson <span class="op">+</span> sigma_chap_poisson, p_chap_poisson <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_poisson</span>
<span id="cb27-318"><a href="#cb27-318" aria-hidden="true" tabindex="-1"></a>    IC_g7_max, IC_g7_min <span class="op">=</span> p_chap_g7 <span class="op">+</span> sigma_chap_g7, p_chap_g7 <span class="op">+</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>sigma_chap_g7</span>
<span id="cb27-319"><a href="#cb27-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-320"><a href="#cb27-320" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [list_r, IC_ginibre_min, IC_ginibre_max, IC_poisson_min, IC_poisson_max, IC_g7_min, IC_g7_max]</span>
<span id="cb27-321"><a href="#cb27-321" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-322"><a href="#cb27-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-323"><a href="#cb27-323" aria-hidden="true" tabindex="-1"></a>@fig-simulation shows the results of the simulations, where we compare the confidence intervals of the poisson process with the Ginibre process and the $0.7$-Ginibre process, using first the central cell and then the five central cells.</span>
<span id="cb27-324"><a href="#cb27-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-325"><a href="#cb27-325" aria-hidden="true" tabindex="-1"></a>:::{#fig-simulation}</span>
<span id="cb27-326"><a href="#cb27-326" aria-hidden="true" tabindex="-1"></a><span class="al">![](./figures/simulation.png)</span>{height=500}</span>
<span id="cb27-327"><a href="#cb27-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-328"><a href="#cb27-328" aria-hidden="true" tabindex="-1"></a>Simulation results using the central cell (up) and the five central cells (down).</span>
<span id="cb27-329"><a href="#cb27-329" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-330"><a href="#cb27-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-331"><a href="#cb27-331" aria-hidden="true" tabindex="-1"></a>The limitation of the statistical approach using only the central cell is made visible by the presence of some overlap between the confidence intervals of the Poisson process and that of the $0.7$-Ginibre process. Consequently, in specific cases, it may not be possible to determine the true nature of some processes based on this statistical test. On the other hand, if we average the ratio of the five most central cells (the cells whose centers are the closest to the origin), there is no longer an overlap among the various curves.</span>
<span id="cb27-332"><a href="#cb27-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-333"><a href="#cb27-333" aria-hidden="true" tabindex="-1"></a>This approach shows that the chosen ratio variable represents a good repulsion criterion. On the other hand, our objective is to decide for a single map which model is the most pertinent, and that cannot be done by a frequentist approach. This is what motivated us to use a ML method.</span>
<span id="cb27-334"><a href="#cb27-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-335"><a href="#cb27-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-336"><a href="#cb27-336" aria-hidden="true" tabindex="-1"></a><span class="fu">### Machine Learning approach</span></span>
<span id="cb27-337"><a href="#cb27-337" aria-hidden="true" tabindex="-1"></a>In this approach, we will use the same circular domain with $N$ points as in the statistical approach. Since the repulsion is not sensitive to scaling, we normalize the radius to $R=\sqrt{N}$. This is due to the fact that a cloud drawn from a Ginibre point process of intensity $1$ with $N$ points occupies roughly a disk with this radius. We begin by generating the data of the Ginibre process, the $0.7$-Ginibre process and the poisson process on which we will train the classification model, which is a Logistic Regression Classifier. Using only the central cell (respectively the five most  central cells), the initial variables in our database consist of the surface and perimeter of the central cell (respectively surfaces and perimeters of the five central cells) of each generated sample, along with a binary variable that takes the value $1$ if the process is repulsive and $0$ otherwise. Subsequently, we add the ratio variable $\frac{4 \pi S}{P^2}$ of the central cell (respectively the five ratios of the five central cells) to provide the classification model with additional information on which to base its predictions. The output of the classifier is a composite score based on some statistics of the point process, tuned to discriminate between a Poisson process and a repulsive point process.</span>
<span id="cb27-338"><a href="#cb27-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-341"><a href="#cb27-341" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-342"><a href="#cb27-342" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dataframe_1cell(N, observations):</span>
<span id="cb27-343"><a href="#cb27-343" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb27-344"><a href="#cb27-344" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb27-345"><a href="#cb27-345" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(beta_ginibre(N, <span class="fl">0.7</span>, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb27-346"><a href="#cb27-346" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb27-347"><a href="#cb27-347" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'process'</span>])</span>
<span id="cb27-348"><a href="#cb27-348" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb27-349"><a href="#cb27-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-350"><a href="#cb27-350" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_1cell(N, observations):</span>
<span id="cb27-351"><a href="#cb27-351" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb27-352"><a href="#cb27-352" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb27-353"><a href="#cb27-353" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(ginibre(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb27-354"><a href="#cb27-354" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb27-355"><a href="#cb27-355" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'process'</span>])</span>
<span id="cb27-356"><a href="#cb27-356" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb27-357"><a href="#cb27-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-358"><a href="#cb27-358" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dataframe_5cells(N, observations):</span>
<span id="cb27-359"><a href="#cb27-359" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb27-360"><a href="#cb27-360" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb27-361"><a href="#cb27-361" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(beta_ginibre(N, <span class="fl">0.7</span>, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb27-362"><a href="#cb27-362" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb27-363"><a href="#cb27-363" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'S2'</span>, <span class="st">'S3'</span>, <span class="st">'S4'</span>, <span class="st">'S5'</span>, <span class="st">'P1'</span>, <span class="st">'P2'</span>, <span class="st">'P3'</span>, <span class="st">'P4'</span>, <span class="st">'P5'</span>, <span class="st">'process'</span>])</span>
<span id="cb27-364"><a href="#cb27-364" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb27-365"><a href="#cb27-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-366"><a href="#cb27-366" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> data_5cells(N, observations):</span>
<span id="cb27-367"><a href="#cb27-367" aria-hidden="true" tabindex="-1"></a>    list_df <span class="op">=</span> []</span>
<span id="cb27-368"><a href="#cb27-368" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(observations):</span>
<span id="cb27-369"><a href="#cb27-369" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(ginibre(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">1</span>])</span>
<span id="cb27-370"><a href="#cb27-370" aria-hidden="true" tabindex="-1"></a>        list_df.append(<span class="bu">sum</span>(<span class="bu">list</span>(poisson(N, cells<span class="op">=</span><span class="dv">5</span>)), []) <span class="op">+</span> [<span class="dv">0</span>])</span>
<span id="cb27-371"><a href="#cb27-371" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(list_df, columns <span class="op">=</span> [<span class="st">'S1'</span>, <span class="st">'S2'</span>, <span class="st">'S3'</span>, <span class="st">'S4'</span>, <span class="st">'S5'</span>, <span class="st">'P1'</span>, <span class="st">'P2'</span>, <span class="st">'P3'</span>, <span class="st">'P4'</span>, <span class="st">'P5'</span>, <span class="st">'process'</span>])</span>
<span id="cb27-372"><a href="#cb27-372" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb27-373"><a href="#cb27-373" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-374"><a href="#cb27-374" aria-hidden="true" tabindex="-1"></a>As the generation of data requires considerable execution time, we will prepare the data locally (using the previous code), by generating, for each classification, a sample of $5000$ observations ($2500$ repulsive and $2500$ non-repulsive) of $N = 50$ points. Then we read them directly as follows:</span>
<span id="cb27-375"><a href="#cb27-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-378"><a href="#cb27-378" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-379"><a href="#cb27-379" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_1 <span class="op">=</span> pd.read_csv(<span class="st">'data/beta_ginibre_1cell.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb27-380"><a href="#cb27-380" aria-hidden="true" tabindex="-1"></a>ginibre_data_1 <span class="op">=</span> pd.read_csv(<span class="st">'data/ginibre_1cell.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb27-381"><a href="#cb27-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-382"><a href="#cb27-382" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_2 <span class="op">=</span> pd.read_csv(<span class="st">'data/beta_ginibre_5cells.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb27-383"><a href="#cb27-383" aria-hidden="true" tabindex="-1"></a>ginibre_data_2 <span class="op">=</span> pd.read_csv(<span class="st">'data/ginibre_5cells.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb27-384"><a href="#cb27-384" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-385"><a href="#cb27-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-386"><a href="#cb27-386" aria-hidden="true" tabindex="-1"></a>Here is an example of the data created of configurations of $0.7$-Ginibre and poisson processes with one cell:</span>
<span id="cb27-387"><a href="#cb27-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-390"><a href="#cb27-390" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-391"><a href="#cb27-391" aria-hidden="true" tabindex="-1"></a>beta_ginibre_data_1.head()</span>
<span id="cb27-392"><a href="#cb27-392" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-393"><a href="#cb27-393" aria-hidden="true" tabindex="-1"></a>Before starting the model's training using the data generated, we will scale the data in order to avoir the concern of overfitting. Here is an example of the scaling of the previous data:</span>
<span id="cb27-394"><a href="#cb27-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-397"><a href="#cb27-397" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-398"><a href="#cb27-398" aria-hidden="true" tabindex="-1"></a>b_ginibre_1 <span class="op">=</span> beta_ginibre_data_1.copy()</span>
<span id="cb27-399"><a href="#cb27-399" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> beta_ginibre_data_1.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb27-400"><a href="#cb27-400" aria-hidden="true" tabindex="-1"></a>    b_ginibre_1[col] <span class="op">=</span> (b_ginibre_1[col] <span class="op">-</span> b_ginibre_1[col].mean()) <span class="op">/</span> b_ginibre_1[col].std()</span>
<span id="cb27-401"><a href="#cb27-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-402"><a href="#cb27-402" aria-hidden="true" tabindex="-1"></a>ginibre_1 <span class="op">=</span> ginibre_data_1.copy()</span>
<span id="cb27-403"><a href="#cb27-403" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ginibre_data_1.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb27-404"><a href="#cb27-404" aria-hidden="true" tabindex="-1"></a>    ginibre_1[col] <span class="op">=</span> (ginibre_1[col] <span class="op">-</span> ginibre_1[col].mean()) <span class="op">/</span> ginibre_1[col].std()</span>
<span id="cb27-405"><a href="#cb27-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-406"><a href="#cb27-406" aria-hidden="true" tabindex="-1"></a>b_ginibre_2 <span class="op">=</span> beta_ginibre_data_2.copy()</span>
<span id="cb27-407"><a href="#cb27-407" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> beta_ginibre_data_2.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb27-408"><a href="#cb27-408" aria-hidden="true" tabindex="-1"></a>    b_ginibre_2[col] <span class="op">=</span> (b_ginibre_2[col] <span class="op">-</span> b_ginibre_2[col].mean()) <span class="op">/</span> b_ginibre_2[col].std()</span>
<span id="cb27-409"><a href="#cb27-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-410"><a href="#cb27-410" aria-hidden="true" tabindex="-1"></a>ginibre_2 <span class="op">=</span> ginibre_data_2.copy()</span>
<span id="cb27-411"><a href="#cb27-411" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ginibre_data_2.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb27-412"><a href="#cb27-412" aria-hidden="true" tabindex="-1"></a>    ginibre_2[col] <span class="op">=</span> (ginibre_2[col] <span class="op">-</span> ginibre_2[col].mean()) <span class="op">/</span> ginibre_2[col].std()</span>
<span id="cb27-413"><a href="#cb27-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-414"><a href="#cb27-414" aria-hidden="true" tabindex="-1"></a>b_ginibre_1.head()</span>
<span id="cb27-415"><a href="#cb27-415" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-416"><a href="#cb27-416" aria-hidden="true" tabindex="-1"></a>Now that the data is gathered, we will train the Logistic Regression model using the baseline model, i.e. all the hyperparameters' values are taken as defaults, (a grid search can be used later in order to select the optimal hyperparameters). Other classification models (Random Forest, Support Vector Machine and XGBoost) have been tested but did not yield more significant results than the chosen classifier. We split each data to a train data and test data in order to see the model's accuracy before testing it on the cartoradio data.</span>
<span id="cb27-417"><a href="#cb27-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-420"><a href="#cb27-420" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-421"><a href="#cb27-421" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb27-422"><a href="#cb27-422" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb27-423"><a href="#cb27-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-424"><a href="#cb27-424" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb27-425"><a href="#cb27-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-426"><a href="#cb27-426" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb27-427"><a href="#cb27-427" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report, roc_curve, roc_auc_score</span>
<span id="cb27-428"><a href="#cb27-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-429"><a href="#cb27-429" aria-hidden="true" tabindex="-1"></a><span class="co"># Useful function for evaluating our model:</span></span>
<span id="cb27-430"><a href="#cb27-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-431"><a href="#cb27-431" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model_Evaluate(model, x_tt, y_tt):</span>
<span id="cb27-432"><a href="#cb27-432" aria-hidden="true" tabindex="-1"></a>    y_pred <span class="op">=</span> model.predict(x_tt)</span>
<span id="cb27-433"><a href="#cb27-433" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(classification_report(y_tt, y_pred))</span>
<span id="cb27-434"><a href="#cb27-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-435"><a href="#cb27-435" aria-hidden="true" tabindex="-1"></a>    cf_matrix <span class="op">=</span> confusion_matrix(y_tt, y_pred)</span>
<span id="cb27-436"><a href="#cb27-436" aria-hidden="true" tabindex="-1"></a>    categories  <span class="op">=</span> [<span class="st">'Negative'</span>,<span class="st">'Positive'</span>]</span>
<span id="cb27-437"><a href="#cb27-437" aria-hidden="true" tabindex="-1"></a>    group_names <span class="op">=</span> [<span class="st">'True Neg'</span>,<span class="st">'False Pos'</span>, <span class="st">'False Neg'</span>,<span class="st">'True Pos'</span>]</span>
<span id="cb27-438"><a href="#cb27-438" aria-hidden="true" tabindex="-1"></a>    group_percentages <span class="op">=</span> [<span class="st">'</span><span class="sc">{0:.2%}</span><span class="st">'</span>.<span class="bu">format</span>(value) <span class="cf">for</span> value <span class="kw">in</span> cf_matrix.flatten() <span class="op">/</span> np.<span class="bu">sum</span>(cf_matrix)]</span>
<span id="cb27-439"><a href="#cb27-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-440"><a href="#cb27-440" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>v1<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>v2<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> v1, v2 <span class="kw">in</span> <span class="bu">zip</span>(group_names,group_percentages)]</span>
<span id="cb27-441"><a href="#cb27-441" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.asarray(labels).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb27-442"><a href="#cb27-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-443"><a href="#cb27-443" aria-hidden="true" tabindex="-1"></a>    logit_roc_auc <span class="op">=</span> roc_auc_score(y_tt, model.predict(x_tt))</span>
<span id="cb27-444"><a href="#cb27-444" aria-hidden="true" tabindex="-1"></a>    fpr, tpr, thresholds <span class="op">=</span> roc_curve(y_tt, model.predict_proba(x_tt)[:,<span class="dv">1</span>])</span>
<span id="cb27-445"><a href="#cb27-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-446"><a href="#cb27-446" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb27-447"><a href="#cb27-447" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adds subplot on position 1</span></span>
<span id="cb27-448"><a href="#cb27-448" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">121</span>)</span>
<span id="cb27-449"><a href="#cb27-449" aria-hidden="true" tabindex="-1"></a>    sns.heatmap(cf_matrix, annot <span class="op">=</span> labels, cmap <span class="op">=</span> <span class="st">'Blues'</span>,fmt <span class="op">=</span> <span class="st">''</span>, xticklabels <span class="op">=</span> categories, yticklabels <span class="op">=</span> categories)</span>
<span id="cb27-450"><a href="#cb27-450" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">"Confusion Matrix"</span>, fontdict <span class="op">=</span> font)</span>
<span id="cb27-451"><a href="#cb27-451" aria-hidden="true" tabindex="-1"></a>    ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'Predicted values'</span>, ylabel<span class="op">=</span><span class="st">'Actual values'</span>)</span>
<span id="cb27-452"><a href="#cb27-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-453"><a href="#cb27-453" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adds subplot on position 2</span></span>
<span id="cb27-454"><a href="#cb27-454" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">122</span>)</span>
<span id="cb27-455"><a href="#cb27-455" aria-hidden="true" tabindex="-1"></a>    ax.plot(fpr, tpr, label<span class="op">=</span><span class="st">'area = </span><span class="sc">%0.2f</span><span class="st">'</span> <span class="op">%</span> logit_roc_auc)</span>
<span id="cb27-456"><a href="#cb27-456" aria-hidden="true" tabindex="-1"></a>    ax.plot([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>],<span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Standard'</span>)</span>
<span id="cb27-457"><a href="#cb27-457" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim([<span class="op">-</span><span class="fl">0.02</span>, <span class="fl">1.02</span>])</span>
<span id="cb27-458"><a href="#cb27-458" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim([<span class="fl">0.0</span>, <span class="fl">1.05</span>])</span>
<span id="cb27-459"><a href="#cb27-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-460"><a href="#cb27-460" aria-hidden="true" tabindex="-1"></a>    thresholds_rounded <span class="op">=</span> [<span class="bu">round</span>(num, <span class="dv">1</span>) <span class="cf">for</span> num <span class="kw">in</span> thresholds]</span>
<span id="cb27-461"><a href="#cb27-461" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> threshold <span class="kw">in</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>]:</span>
<span id="cb27-462"><a href="#cb27-462" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> threshold <span class="kw">in</span> thresholds_rounded:</span>
<span id="cb27-463"><a href="#cb27-463" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> thresholds_rounded.index(threshold)</span>
<span id="cb27-464"><a href="#cb27-464" aria-hidden="true" tabindex="-1"></a>            ax.annotate(threshold, (fpr[index], tpr[index]))</span>
<span id="cb27-465"><a href="#cb27-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-466"><a href="#cb27-466" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="st">'Receiver Operating Characteristic (ROC)'</span>, fontdict <span class="op">=</span> font)</span>
<span id="cb27-467"><a href="#cb27-467" aria-hidden="true" tabindex="-1"></a>    ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">'False Positive Rate (1-specificity)'</span>, ylabel<span class="op">=</span><span class="st">'True Positive Rate (sensitivity)'</span>)</span>
<span id="cb27-468"><a href="#cb27-468" aria-hidden="true" tabindex="-1"></a>    ax.legend(loc<span class="op">=</span><span class="st">"lower right"</span>)</span>
<span id="cb27-469"><a href="#cb27-469" aria-hidden="true" tabindex="-1"></a>    ax.grid()</span>
<span id="cb27-470"><a href="#cb27-470" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb27-471"><a href="#cb27-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-472"><a href="#cb27-472" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-473"><a href="#cb27-473" aria-hidden="true" tabindex="-1"></a>Here are the results of the classification using each data:</span>
<span id="cb27-474"><a href="#cb27-474" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$0.7$-Ginibre Vs Poisson using the central cell:</span>
<span id="cb27-475"><a href="#cb27-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-478"><a href="#cb27-478" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-479"><a href="#cb27-479" aria-hidden="true" tabindex="-1"></a>beta_X1 <span class="op">=</span> b_ginibre_1[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]].values</span>
<span id="cb27-480"><a href="#cb27-480" aria-hidden="true" tabindex="-1"></a>beta_y1 <span class="op">=</span> b_ginibre_1[<span class="st">'process'</span>].values</span>
<span id="cb27-481"><a href="#cb27-481" aria-hidden="true" tabindex="-1"></a>beta_X1_train, beta_X1_test, beta_y1_train, beta_y1_test <span class="op">=</span> train_test_split(beta_X1, beta_y1, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb27-482"><a href="#cb27-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-483"><a href="#cb27-483" aria-hidden="true" tabindex="-1"></a>beta_LR1 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb27-484"><a href="#cb27-484" aria-hidden="true" tabindex="-1"></a>beta_LR1.fit(beta_X1_train, beta_y1_train)</span>
<span id="cb27-485"><a href="#cb27-485" aria-hidden="true" tabindex="-1"></a>model_Evaluate(beta_LR1, beta_X1_test, beta_y1_test)</span>
<span id="cb27-486"><a href="#cb27-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-487"><a href="#cb27-487" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ginibre Vs Poisson using the central cell:</span>
<span id="cb27-488"><a href="#cb27-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-491"><a href="#cb27-491" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-492"><a href="#cb27-492" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> ginibre_1[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]].values</span>
<span id="cb27-493"><a href="#cb27-493" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> ginibre_1[<span class="st">'process'</span>].values</span>
<span id="cb27-494"><a href="#cb27-494" aria-hidden="true" tabindex="-1"></a>X1_train, X1_test, y1_train, y1_test <span class="op">=</span> train_test_split(X1, y1, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb27-495"><a href="#cb27-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-496"><a href="#cb27-496" aria-hidden="true" tabindex="-1"></a>LR1 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb27-497"><a href="#cb27-497" aria-hidden="true" tabindex="-1"></a>LR1.fit(X1_train, y1_train)</span>
<span id="cb27-498"><a href="#cb27-498" aria-hidden="true" tabindex="-1"></a>model_Evaluate(LR1, X1_test, y1_test)</span>
<span id="cb27-499"><a href="#cb27-499" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-500"><a href="#cb27-500" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$0.7$-Ginibre Vs Poisson using the five central cells:</span>
<span id="cb27-501"><a href="#cb27-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-504"><a href="#cb27-504" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-505"><a href="#cb27-505" aria-hidden="true" tabindex="-1"></a>beta_X2 <span class="op">=</span> b_ginibre_2[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]].values</span>
<span id="cb27-506"><a href="#cb27-506" aria-hidden="true" tabindex="-1"></a>beta_y2 <span class="op">=</span> b_ginibre_2[<span class="st">'process'</span>].values</span>
<span id="cb27-507"><a href="#cb27-507" aria-hidden="true" tabindex="-1"></a>beta_X2_train, beta_X2_test, beta_y2_train, beta_y2_test <span class="op">=</span> train_test_split(beta_X2, beta_y2, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb27-508"><a href="#cb27-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-509"><a href="#cb27-509" aria-hidden="true" tabindex="-1"></a>beta_LR2 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb27-510"><a href="#cb27-510" aria-hidden="true" tabindex="-1"></a>beta_LR2.fit(beta_X2_train, beta_y2_train)</span>
<span id="cb27-511"><a href="#cb27-511" aria-hidden="true" tabindex="-1"></a>model_Evaluate(beta_LR2, beta_X2_test, beta_y2_test)</span>
<span id="cb27-512"><a href="#cb27-512" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-513"><a href="#cb27-513" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ginibre Vs Poisson using the five central cells:</span>
<span id="cb27-514"><a href="#cb27-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-517"><a href="#cb27-517" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-518"><a href="#cb27-518" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> ginibre_2[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]].values</span>
<span id="cb27-519"><a href="#cb27-519" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> ginibre_2[<span class="st">'process'</span>].values</span>
<span id="cb27-520"><a href="#cb27-520" aria-hidden="true" tabindex="-1"></a>X2_train, X2_test, y2_train, y2_test <span class="op">=</span> train_test_split(X2, y2, test_size<span class="op">=</span><span class="fl">0.3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb27-521"><a href="#cb27-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-522"><a href="#cb27-522" aria-hidden="true" tabindex="-1"></a>LR2 <span class="op">=</span> make_pipeline(StandardScaler(), LogisticRegression())</span>
<span id="cb27-523"><a href="#cb27-523" aria-hidden="true" tabindex="-1"></a>LR2.fit(X2_train, y2_train)</span>
<span id="cb27-524"><a href="#cb27-524" aria-hidden="true" tabindex="-1"></a>model_Evaluate(LR2, X2_test, y2_test)</span>
<span id="cb27-525"><a href="#cb27-525" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-526"><a href="#cb27-526" aria-hidden="true" tabindex="-1"></a>We can notice that our model's accuracy when using the central cell is approximately $70\%$ for the Ginibre and Poisson processes classification. However, when considering the first five central cells, we achieve an accuracy of $85 \%$, a result consistent with our statistical approach. This is because with the five cells, the model has access to more information about the nature of the sample, increasing the likelihood of successful sample classification by taking into account the surface areas and perimeters of the first five central cells.</span>
<span id="cb27-527"><a href="#cb27-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-528"><a href="#cb27-528" aria-hidden="true" tabindex="-1"></a><span class="fu">### Cartoradio data Tests</span></span>
<span id="cb27-529"><a href="#cb27-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-530"><a href="#cb27-530" aria-hidden="true" tabindex="-1"></a>Cartoradio data is a set of configurations of some mobile phone base stations in Paris. The goal is to decide from the classification model already used, whether the configuration do present some repulsion.</span>
<span id="cb27-531"><a href="#cb27-531" aria-hidden="true" tabindex="-1"></a>serait</span>
<span id="cb27-532"><a href="#cb27-532" aria-hidden="true" tabindex="-1"></a>The initial data (positions of the antennas) cover a large area of the city of Paris (see @fig-cartoradio (right))</span>
<span id="cb27-533"><a href="#cb27-533" aria-hidden="true" tabindex="-1"></a>With a real dataset,  we often encounter the problem of heterogeneity between the different parts of the configurations since they depend on the topology  of the space in which the antennas are placed.</span>
<span id="cb27-534"><a href="#cb27-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-535"><a href="#cb27-535" aria-hidden="true" tabindex="-1"></a>To cope with this problem, we  extract from each configuration a representative sample similar to the type of training data so that the tests make sense. @fig-cartoradio (left) shows a sample extracted from a given configuration.</span>
<span id="cb27-536"><a href="#cb27-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-537"><a href="#cb27-537" aria-hidden="true" tabindex="-1"></a>:::{#fig-cartoradio}</span>
<span id="cb27-538"><a href="#cb27-538" aria-hidden="true" tabindex="-1"></a><span class="al">![](./figures/cartoradio.png)</span></span>
<span id="cb27-539"><a href="#cb27-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-540"><a href="#cb27-540" aria-hidden="true" tabindex="-1"></a>On the left, Initial cartoradio configuration. On the right, Sample extracted from it and scaled.</span>
<span id="cb27-541"><a href="#cb27-541" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb27-542"><a href="#cb27-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-543"><a href="#cb27-543" aria-hidden="true" tabindex="-1"></a>In the following, we read the cartoradio data directly from the "cartoradio_data.csv" file, then we add the variables that represent the ratio of the first five central cell and finally we scale the data. Here is the final (scaled) data on which we will test our model.</span>
<span id="cb27-544"><a href="#cb27-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-545"><a href="#cb27-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-548"><a href="#cb27-548" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-549"><a href="#cb27-549" aria-hidden="true" tabindex="-1"></a>cartoradio <span class="op">=</span> pd.read_csv(<span class="st">'data/cartoradio_data.csv'</span>, sep<span class="op">=</span><span class="st">','</span>)</span>
<span id="cb27-550"><a href="#cb27-550" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R1'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A1<span class="op">/</span>(cartoradio.P1)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-551"><a href="#cb27-551" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R2'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A2<span class="op">/</span>(cartoradio.P2)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-552"><a href="#cb27-552" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R3'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A3<span class="op">/</span>(cartoradio.P3)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-553"><a href="#cb27-553" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R4'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A4<span class="op">/</span>(cartoradio.P4)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-554"><a href="#cb27-554" aria-hidden="true" tabindex="-1"></a>cartoradio[<span class="st">'R5'</span>] <span class="op">=</span> <span class="bu">list</span>(<span class="dv">4</span><span class="op">*</span>np.pi<span class="op">*</span>cartoradio.A5<span class="op">/</span>(cartoradio.P5)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb27-555"><a href="#cb27-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-556"><a href="#cb27-556" aria-hidden="true" tabindex="-1"></a>cartoradio.rename(columns<span class="op">=</span>{<span class="st">'A1'</span>: <span class="st">'S1'</span>, <span class="st">'A2'</span>: <span class="st">'S2'</span>, <span class="st">'A3'</span>:<span class="st">'S3'</span>, <span class="st">'A4'</span>:<span class="st">'S4'</span>, <span class="st">'A5'</span>:<span class="st">'S5'</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb27-557"><a href="#cb27-557" aria-hidden="true" tabindex="-1"></a>cartoradio <span class="op">=</span> cartoradio[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>, <span class="st">'S2'</span>, <span class="st">'P2'</span>, <span class="st">'R2'</span>, <span class="st">'S3'</span>, <span class="st">'P3'</span>, <span class="st">'R3'</span>, <span class="st">'S4'</span>, <span class="st">'P4'</span>, <span class="st">'R4'</span>, <span class="st">'S5'</span>, <span class="st">'P5'</span>, <span class="st">'R5'</span>]]</span>
<span id="cb27-558"><a href="#cb27-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-559"><a href="#cb27-559" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled <span class="op">=</span> cartoradio.copy()</span>
<span id="cb27-560"><a href="#cb27-560" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cartoradio.columns[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb27-561"><a href="#cb27-561" aria-hidden="true" tabindex="-1"></a>    cartoradio_scaled[col] <span class="op">=</span> (cartoradio_scaled[col] <span class="op">-</span> cartoradio_scaled[col].mean()) <span class="op">/</span> cartoradio_scaled[col].std()</span>
<span id="cb27-562"><a href="#cb27-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-563"><a href="#cb27-563" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled_1 <span class="op">=</span> cartoradio_scaled[[<span class="st">'S1'</span>, <span class="st">'P1'</span>, <span class="st">'R1'</span>]]</span>
<span id="cb27-564"><a href="#cb27-564" aria-hidden="true" tabindex="-1"></a>cartoradio_scaled.head()</span>
<span id="cb27-565"><a href="#cb27-565" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-566"><a href="#cb27-566" aria-hidden="true" tabindex="-1"></a>Here are the results of the tests on the cartoradio data using each model already trained, showing the classification value and its probability for each observation.</span>
<span id="cb27-567"><a href="#cb27-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-568"><a href="#cb27-568" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$0.7$-Ginibre Vs Poisson using the central cell:</span>
<span id="cb27-569"><a href="#cb27-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-572"><a href="#cb27-572" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-573"><a href="#cb27-573" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, beta_LR1.predict(np.array(cartoradio_scaled_1)))</span>
<span id="cb27-574"><a href="#cb27-574" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, beta_LR1.predict_proba(np.array(cartoradio_scaled_1)))</span>
<span id="cb27-575"><a href="#cb27-575" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-576"><a href="#cb27-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-577"><a href="#cb27-577" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ginibre Vs Poisson using the central cell:</span>
<span id="cb27-578"><a href="#cb27-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-581"><a href="#cb27-581" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-582"><a href="#cb27-582" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, LR1.predict(np.array(cartoradio_scaled_1)))</span>
<span id="cb27-583"><a href="#cb27-583" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, LR1.predict_proba(np.array(cartoradio_scaled_1)))</span>
<span id="cb27-584"><a href="#cb27-584" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-585"><a href="#cb27-585" aria-hidden="true" tabindex="-1"></a>It can be noted that the classification results using only the central cell are not significant enough. This is largely due to the low accuracy of the model used with the central cell, which is normal since the data does not contain enough variables for the model's training.</span>
<span id="cb27-586"><a href="#cb27-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-587"><a href="#cb27-587" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$0.7$-Ginibre Vs Poisson using the five central cell:</span>
<span id="cb27-588"><a href="#cb27-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-591"><a href="#cb27-591" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-592"><a href="#cb27-592" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, beta_LR2.predict(np.array(cartoradio_scaled)))</span>
<span id="cb27-593"><a href="#cb27-593" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, beta_LR2.predict_proba(np.array(cartoradio_scaled)))</span>
<span id="cb27-594"><a href="#cb27-594" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-595"><a href="#cb27-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-596"><a href="#cb27-596" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ginibre Vs Poisson using the five central cell:</span>
<span id="cb27-597"><a href="#cb27-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-600"><a href="#cb27-600" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb27-601"><a href="#cb27-601" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification results:'</span>, LR2.predict(np.array(cartoradio_scaled)))</span>
<span id="cb27-602"><a href="#cb27-602" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Classification probabilities:</span><span class="ch">\n</span><span class="st">'</span>, LR2.predict_proba(np.array(cartoradio_scaled)))</span>
<span id="cb27-603"><a href="#cb27-603" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb27-604"><a href="#cb27-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-605"><a href="#cb27-605" aria-hidden="true" tabindex="-1"></a>In contrast, the results found using the five central cells are much better, the majority of configurations are classified as repulsive. Regarding the configurations classified as non-repulsive by our model, we can say that this comes down to one of the following two reasons:</span>
<span id="cb27-606"><a href="#cb27-606" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>As long as we are dealing with real data, these samples may be a non-repulsive ones and the results are actually coherent.</span>
<span id="cb27-607"><a href="#cb27-607" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>It is sure that the accuracy of our models is high, but we may have some classification errors, which means that even if the configuration is repulsive, the model decides that it is not.</span>
<span id="cb27-608"><a href="#cb27-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-609"><a href="#cb27-609" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb27-610"><a href="#cb27-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-611"><a href="#cb27-611" aria-hidden="true" tabindex="-1"></a>In this paper it has been shown numerically (based on the theoretical results in @goldman_palm_2010) that Voronoi cells represent an effective means for determining the nature of repulsion of a configuration (repulsive or not), and this by creating a database of various configurations and extracting the areas and perimeters of the Voronoi cells in order to use them as input to the classification model described earlier.</span>
<span id="cb27-612"><a href="#cb27-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-613"><a href="#cb27-613" aria-hidden="true" tabindex="-1"></a>Once the model is trained and tested on the data created, it is tested after that on real data, which are the positions of a mobile phone base stations in Paris. Visually, we can easily say that these configurations are repulsive, which we have confirmed for the majority of these configurations by testing them by the previously trained model, especially the one classifying Ginibre and poisson processes using the first five central cells.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>